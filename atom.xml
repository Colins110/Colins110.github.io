<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Colin&#39;s Home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.colins110.cn/"/>
  <updated>2020-06-27T03:40:51.558Z</updated>
  <id>https://www.colins110.cn/</id>
  
  <author>
    <name>Colin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>raft原理</title>
    <link href="https://www.colins110.cn/2020/06/27/raft%E5%8E%9F%E7%90%86/"/>
    <id>https://www.colins110.cn/2020/06/27/raft原理/</id>
    <published>2020-06-27T03:07:38.000Z</published>
    <updated>2020-06-27T03:40:51.558Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>关于Raft原理，许多朋友也许不是很明白原理，下面的地址是一个好玩的Raft动画，看完后能够很快的掌握Raft原理：<br><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></p><p>动画中的一些概念和简要原理总结如下：<br><img src="/2020/06/27/raft原理/1.png" alt=""></p><h2 id="raft原理"><a href="#raft原理" class="headerlink" title="raft原理"></a>raft原理</h2><p>在Raft中，每个结点会处于下面三种状态中的一种：</p><ol><li><p>follower：所有结点都以follower的状态开始。如果没收到leader消息则会变成candidate状态。</p></li><li><p>candidate：会向其他结点“拉选票”，如果得到大部分的票则成为leader。这个过程就叫做Leader选举(Leader Election)。</p></li><li><p>leader：所有对系统的修改都会先经过leader。每个修改都会写一条日志(log entry)。leader收到修改请求后的过程如下，这个过程叫做日志复制(Log Replication)：</p></li></ol><ul><li>复制日志到所有follower结点(replicate entry)</li><li>大部分结点响应时才提交日志</li><li>通知所有follower结点日志已提交</li><li>所有follower也提交日志</li><li>现在整个系统处于一致的状态</li></ul><p>三种角色的状态转换关系如下:<br><img src="/2020/06/27/raft原理/2.png" alt=""></p><h3 id="Leader-Election"><a href="#Leader-Election" class="headerlink" title="Leader Election"></a>Leader Election</h3><p>当follower在选举超时时间(election timeout)内未收到leader的心跳消息(append entries)，则变成candidate状态。为了避免选举冲突，这个超时时间是一个150~300ms之间的随机数。</p><p>成为candidate的结点发起新的选举期(election term)去“拉选票”：</p><ul><li>重置自己的计时器</li><li>投自己一票</li><li>发送 Request Vote消息<br>如果接收结点在新term内没有投过票那它就会投给此candidate，并重置它自己的选举超时时间。candidate拉到大部分选票就会成为leader，并定时发送心跳——Append Entries消息，去重置各个follower的计时器。当前Term会继续直到某个follower接收不到心跳并成为candidate。</li></ul><p>如果不巧两个结点同时成为candidate都去“拉票”怎么办？这时会发生Splite Vote情况。两个结点可能都拉到了同样多的选票，难分胜负，选举失败，本term没有leader。之后又有计时器超时的follower会变成candidate，将term加一并开始新一轮的投票。</p><h3 id="Log-Replication"><a href="#Log-Replication" class="headerlink" title="Log Replication"></a>Log Replication</h3><p>当发生改变时，leader会复制日志给follower结点，这也是通过Append Entries心跳消息完成的。前面已经列举了Log Replication的过程，这里就不重复了。</p><p>Raft能够正确地处理网络分区（“脑裂”）问题。假设A~E五个结点，B是leader。如果发生“脑裂”，A、B成为一个子分区，C、D、E成为一个子分区。此时C、D、E会发生选举，选出C作为新term的leader。这样我们在两个子分区内就有了不同term的两个leader。这时如果有客户端写A时，因为B无法复制日志到大部分follower所以日志处于uncommitted未提交状态。而同时另一个客户端对C的写操作却能够正确完成，因为C是新的leader，它只知道D和E。</p><p>当网络通信恢复，B能够发送心跳给C、D、E了，却发现“改朝换代”了，因为C的term值更大，所以B自动降格为follower。然后A和B都回滚未提交的日志，并从新leader那里复制最新的日志。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="分布式" scheme="https://www.colins110.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="raft" scheme="https://www.colins110.cn/tags/raft/"/>
    
  </entry>
  
  <entry>
    <title>devicemapper源码理解</title>
    <link href="https://www.colins110.cn/2020/04/01/devicemapper%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/"/>
    <id>https://www.colins110.cn/2020/04/01/devicemapper源码理解/</id>
    <published>2020-04-01T06:00:34.000Z</published>
    <updated>2020-04-05T09:19:12.376Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="device-mapper-h"><a href="#device-mapper-h" class="headerlink" title="device-mapper.h"></a>device-mapper.h</h1><p>table的类型，mapped_device 的内存池和请求队列<br>enum dm_queue_mode {<br>    DM_TYPE_NONE         = 0,<br>    DM_TYPE_BIO_BASED     = 1,<br>    DM_TYPE_REQUEST_BASED     = 2,<br>    DM_TYPE_MQ_REQUEST_BASED = 3,<br>    DM_TYPE_DAX_BIO_BASED     = 4,<br>};</p><p>一些函数原型如：<br>typedef int (<em>dm_ctr_fn) (struct dm_target </em>target,<br>              unsigned int argc, char **argv);</p><p>/*</p><ul><li>The map function must return:</li><li>&lt; 0: error</li><li>= 0: The target will handle the io by resubmitting it later</li><li>= 1: simple remap complete</li><li>= 2: The target wants to push back the io<br><em>/<br>typedef int (</em>dm_map_fn) (struct dm_target <em>ti, struct bio </em>bio);</li></ul><p>/*</p><ul><li>Returns:</li><li>&lt; 0 : error (currently ignored)</li><li>0   : ended successfully</li><li>1   : for some reason the io has still not completed (eg,</li><li>multipath target might want to requeue a failed io).</li><li>2   : The target wants to push back the io<br><em>/<br>typedef int (</em>dm_endio_fn) (struct dm_target *ti,<pre><code>struct bio *bio, int error);</code></pre></li></ul><h2 id="target-type"><a href="#target-type" class="headerlink" title="target_type"></a>target_type</h2><p>struct target_type {<br>    uint64_t features;<br>    const char <em>name;<br>    struct module </em>module;<br>    unsigned version[3];<br>    dm_ctr_fn ctr;<br>    dm_dtr_fn dtr;<br>    dm_map_fn map;<br>    dm_map_request_fn map_rq;<br>    dm_clone_and_map_request_fn clone_and_map_rq;<br>    dm_release_clone_request_fn release_clone_rq;<br>    dm_endio_fn end_io;<br>    dm_request_endio_fn rq_end_io;<br>    dm_presuspend_fn presuspend;<br>    dm_presuspend_undo_fn presuspend_undo;<br>    dm_postsuspend_fn postsuspend;<br>    dm_preresume_fn preresume;<br>    dm_resume_fn resume;<br>    dm_status_fn status;<br>    dm_message_fn message;<br>    dm_prepare_ioctl_fn prepare_ioctl;<br>    dm_merge_fn merge;<br>    dm_busy_fn busy;<br>    dm_iterate_devices_fn iterate_devices;<br>    dm_io_hints_fn io_hints;<br>    dm_dax_direct_access_fn direct_access;<br>    dm_dax_memcpy_fromiovecend_fn dax_memcpy_fromiovecend;<br>    dm_dax_memcpy_toiovecend_fn dax_memcpy_toiovecend;</p><pre><code>/* For internal device-mapper use. */struct list_head list;</code></pre><p>};</p><p>2020-4-5<br>从devicemapper 初始化开始看：<br>在dm-ioctl.c中<br>创建混杂设备(混杂设备是一种字符设备)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">init <span class="title">dm_interface_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">r = dm_hash_init();</span><br><span class="line"><span class="keyword">if</span> (r)</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">r = misc_register(&amp;_dm_misc); <span class="comment">//注册混杂设备</span></span><br><span class="line"><span class="keyword">if</span> (r) &#123;</span><br><span class="line">DMERR(<span class="string">"misc_register failed for control device"</span>);</span><br><span class="line">dm_hash_exit();</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DMINFO(<span class="string">"%d.%d.%d%s initialised: %s"</span>, DM_VERSION_MAJOR,</span><br><span class="line">       DM_VERSION_MINOR, DM_VERSION_PATCHLEVEL, DM_VERSION_EXTRA,</span><br><span class="line">       DM_DRIVER_EMAIL);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在dm.c 调用并初始化<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> _<span class="title">dm_misc</span> = &#123;</span></span><br><span class="line">.minor= MAPPER_CTRL_MINOR,</span><br><span class="line">.name  = DM_NAME,</span><br><span class="line">.nodename= DM_DIR <span class="string">"/"</span> DM_CONTROL_NODE,</span><br><span class="line">.fops  = &amp;_ctl_fops <span class="comment">//设置混杂设备的一些操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>混杂设备具体的操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> _<span class="title">ctl_fops</span> = &#123;</span></span><br><span class="line">.open    = dm_open,</span><br><span class="line">.release = dm_release,</span><br><span class="line">.poll    = dm_poll,</span><br><span class="line">.unlocked_ioctl = dm_ctl_ioctl,</span><br><span class="line">.compat_ioctl = dm_compat_ctl_ioctl,</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.llseek  = noop_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在dm_ctl_ioctl中实现具体的ioctl操作<br>dm_ctl_ioctl() -&gt; ctl_ioctl() -&gt; lookup_ioctl() //查找对应的ioctl操作<br>在 ctl_ioctl中执行对应的ioctl操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ioctl_fn <span class="title">lookup_ioctl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">int</span> *ioctl_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> cmd;</span><br><span class="line"><span class="keyword">int</span> flags;</span><br><span class="line">ioctl_fn fn;</span><br><span class="line">&#125; _ioctls[] = &#123;</span><br><span class="line">&#123;DM_VERSION_CMD, <span class="number">0</span>, <span class="literal">NULL</span>&#125;, <span class="comment">/* version is dealt with elsewhere */</span></span><br><span class="line">&#123;DM_REMOVE_ALL_CMD, IOCTL_FLAGS_NO_PARAMS | IOCTL_FLAGS_ISSUE_GLOBAL_EVENT, remove_all&#125;,</span><br><span class="line">&#123;DM_LIST_DEVICES_CMD, <span class="number">0</span>, list_devices&#125;,</span><br><span class="line"></span><br><span class="line">&#123;DM_DEV_CREATE_CMD, IOCTL_FLAGS_NO_PARAMS | IOCTL_FLAGS_ISSUE_GLOBAL_EVENT, dev_create&#125;,</span><br><span class="line">&#123;DM_DEV_REMOVE_CMD, IOCTL_FLAGS_NO_PARAMS | IOCTL_FLAGS_ISSUE_GLOBAL_EVENT, dev_remove&#125;,</span><br><span class="line">&#123;DM_DEV_RENAME_CMD, IOCTL_FLAGS_ISSUE_GLOBAL_EVENT, dev_rename&#125;,</span><br><span class="line">&#123;DM_DEV_SUSPEND_CMD, IOCTL_FLAGS_NO_PARAMS, dev_suspend&#125;,</span><br><span class="line">&#123;DM_DEV_STATUS_CMD, IOCTL_FLAGS_NO_PARAMS, dev_status&#125;,</span><br><span class="line">&#123;DM_DEV_WAIT_CMD, <span class="number">0</span>, dev_wait&#125;,</span><br><span class="line"></span><br><span class="line">&#123;DM_TABLE_LOAD_CMD, <span class="number">0</span>, table_load&#125;,</span><br><span class="line">&#123;DM_TABLE_CLEAR_CMD, IOCTL_FLAGS_NO_PARAMS, table_clear&#125;,</span><br><span class="line">&#123;DM_TABLE_DEPS_CMD, <span class="number">0</span>, table_deps&#125;,</span><br><span class="line">&#123;DM_TABLE_STATUS_CMD, <span class="number">0</span>, table_status&#125;,</span><br><span class="line"></span><br><span class="line">&#123;DM_LIST_VERSIONS_CMD, <span class="number">0</span>, list_versions&#125;,</span><br><span class="line"></span><br><span class="line">&#123;DM_TARGET_MSG_CMD, <span class="number">0</span>, target_message&#125;,</span><br><span class="line">&#123;DM_DEV_SET_GEOMETRY_CMD, <span class="number">0</span>, dev_set_geometry&#125;,</span><br><span class="line">&#123;DM_DEV_ARM_POLL, IOCTL_FLAGS_NO_PARAMS, dev_arm_poll&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(cmd &gt;= ARRAY_SIZE(_ioctls)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">*ioctl_flags = _ioctls[cmd].flags;</span><br><span class="line"><span class="keyword">return</span> _ioctls[cmd].fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下创建一个mapping device的过程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dev_create</span><span class="params">(struct file *filp, struct dm_ioctl *param, <span class="keyword">size_t</span> param_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r, m = DM_ANY_MINOR;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mapped_device</span> *<span class="title">md</span>;</span></span><br><span class="line"></span><br><span class="line">r = check_name(param-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (r)</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (param-&gt;flags &amp; DM_PERSISTENT_DEV_FLAG)</span><br><span class="line">m = MINOR(huge_decode_dev(param-&gt;dev));</span><br><span class="line"></span><br><span class="line">r = dm_create(m, &amp;md);</span><br><span class="line"><span class="keyword">if</span> (r)</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">r = dm_hash_insert(param-&gt;name, *param-&gt;uuid ? param-&gt;uuid : <span class="literal">NULL</span>, md);</span><br><span class="line"><span class="keyword">if</span> (r) &#123;</span><br><span class="line">dm_put(md);</span><br><span class="line">dm_destroy(md);</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">param-&gt;flags &amp;= ~DM_INACTIVE_PRESENT_FLAG;</span><br><span class="line"></span><br><span class="line">__dev_status(md, param);</span><br><span class="line"></span><br><span class="line">dm_put(md);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[转]理解Makefile中的KERNELRELEASE</title>
    <link href="https://www.colins110.cn/2020/03/17/%E8%BD%AC-%E7%90%86%E8%A7%A3Makefile%E4%B8%AD%E7%9A%84KERNELRELEASE/"/>
    <id>https://www.colins110.cn/2020/03/17/转-理解Makefile中的KERNELRELEASE/</id>
    <published>2020-03-16T16:45:32.000Z</published>
    <updated>2020-03-16T16:48:36.231Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Linux内核是一种单体内核，但是通过动态加载模块的方式，使它的开发非常灵活方便。那么，它是如何编译内核的呢？我们可以通过分析它的Makefile入手。以下是一个简单的hello内核模块的Makefile.</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#########################Makefile1#########################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line"></span><br><span class="line"><span class="section">obj-m:=hello.o</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">KERNELDIR:=/lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line"></span><br><span class="line">PWD:=<span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">default:       <span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span>  M=<span class="variable">$(PWD)</span> modules</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:       rm -rf *.o *.mod.c *.mod.o *.ko</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#########################Makefile2#########################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line"></span><br><span class="line">obj-m :=hello.o</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">KDIR:= /lib/modules/2.6.29.4-167.fc11.i686.PAE/build</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line"></span><br><span class="line">             make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line"></span><br><span class="line">rm -f *.ko *.o *.mod.o *.mod.c .symvers</span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#########################Makefile3#########################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line"></span><br><span class="line">obj-m := hello.o</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">PWD  := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line">KVER := <span class="variable">$(<span class="built_in">shell</span> uname -r)</span></span><br><span class="line"></span><br><span class="line">KDIR := /lib/modules/<span class="variable">$(KVER)</span>/build</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line"></span><br><span class="line">       <span class="variable">$(MAKE)</span> -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line"></span><br><span class="line">       rm -rf .*.cmd *.o *.mod.c *.ko .tmp_versions</span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################################</span></span><br></pre></td></tr></table></figure><p>当我们写完一个hello模块，只要使用以上的makefile。然后make一下就行。假设我们把hello模块的源代码放在/home/study/prog/mod/hello/下。当我们在这个目录运行make时，make是怎么执行的呢？ LDD3第二章第四节“编译和装载”中只是简略地说到该Makefile被执行了两次，但是具体过程是如何的呢？</p><p>首先，由于make 后面没有目标，所以make会在Makefile中的第一个不是以.开头的目标作为默认的目标执行。于是default成为make的目标。make会执行 $(MAKE) -C $(KERNELDIR) M=$(PWD) modules</p><p>shell是make内部的函数,假设当前内核版本是2.6.13-study,所以$(shell uname -r)的结果是 2.6.13-study 这里，实际运行的是</p><p>make -C /lib/modules/2.6.13-study/build M=/home/study/prog/mod/hello/ modules，/lib/modules/2.6.13-study/build是一个指向内核源代码/usr/src/linux的符号链接。可见，make执行了两次。第一次执行时是读hello模块的源代码所在目录/home/s tudy/prog/mod/hello/下的Makefile。</p><p>第二次执行时是执行/usr/src/linux/下的Makefile时.</p><p>但是还是有不少令人困惑的问题： 1.这个KERNELRELEASE也很令人困惑，它是什么呢？在/home/study/prog/mod/hello/Makefile中是没有定义这个变量的，所以起作用的是else…endif这一段。不过，如果把hello模块移动到内核源代码中。例如放到/usr/src/linux/driver/中， KERNELRELEASE就有定义了。</p><p>在/usr/src/linux/Makefile中有 162 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)$(LOCALVERSION) 这时候，hello模块也不再是单独用make编译，而是在内核中用make modules进行 编译。</p><p>用这种方式，该Makefile在单独编译和作为内核一部分编译时都能正常工作。</p><p>2.这个obj-m := hello.o什么时候会执行到呢？ 在执行：</p><p>make -C /lib/modules/2.6.13-study/build M=/home/study/prog/mod/hello/ modules时，make 去/usr/src/linux/Makefile中寻找目标modules: 862 .PHONY: modules 863 modules: $(vmlinux-dirs) $(if $(KBUILD_BUILTIN),vmlinux) 864 @echo ‘ Building modules, stage 2.’; 865 $(Q)$(MAKE) -rR -f $(srctree)/scripts/Makefile.modpost</p><p>可以看出，分两个stage: 1.编译出hello.o文件。 2.生成hello.mod.o hello.ko 在这过程中，会调用 make -f scripts/Makefile.build obj=/home/study/prog/mod/hello 而在 scripts/Makefile.build会包含很多文件： 011 -include .config 012 013 include $(if $(wildcard $(obj)/Kbuild), $(obj)/Kbuild, $(obj)/Makefile) 其中就有/home/study/prog/mod/hello/Makefile 这时 KERNELRELEASE已经存在。所以执行的是： obj-m:=hello.o</p><p>关于make modules的更详细的过程可以在scripts/Makefile.modpost文件的注释中找到。如果想查看make的整个执行过程，可以运行make -n。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">"feixiaoxing"</span>);</span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"This is just a hello module!\n"</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   printk(KERN_EMERG <span class="string">"hello, init\n"</span>);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   printk(KERN_EMERG <span class="string">"hello, exit\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line"></span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure><p>加载模块就是输入insmod hello.ko，卸载模块就是rmmod hello。在这过程中，我们都可以看到相应的打印内容。当然，朋友们可以一直往里面加代码，一步步调试，一步步学习，只要坚持和总结，都是可以学习好linux的驱动代码的。</p><p>转自<a href="http://http://blog.sina.com.cn/s/blog_7da9e4aa0101lrp9.html" target="_blank" rel="noopener">《理解Makefile中的KERNELRELEASE》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="kernel" scheme="https://www.colins110.cn/categories/kernel/"/>
    
    
      <category term="makefile" scheme="https://www.colins110.cn/tags/makefile/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu下编译内核模块</title>
    <link href="https://www.colins110.cn/2020/03/17/ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/"/>
    <id>https://www.colins110.cn/2020/03/17/ubuntu下编译内核模块/</id>
    <published>2020-03-16T16:21:44.000Z</published>
    <updated>2020-03-16T16:27:06.402Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在ubuntu下编写内核模块，需要一个源文件和一个makefile文件。<br>模块源文件<strong>hello.c</strong>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line">MODULE_LICENSE(<span class="string">"Dual BSD/GPL"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">"Hello,world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">"GoodBye,colin!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure></p><p>makefile文件:<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Comment/uncomment the following line to disable/enable debugging</span></span><br><span class="line"><span class="comment">#DEBUG = y</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add your debugging flag (or not) to CFLAGS</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>,y)</span><br><span class="line">  DEBFLAGS = -O -g -DSCULL_DEBUG <span class="comment"># "-O" is needed to expand inlines</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  DEBFLAGS = -O2</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">LDDINC=<span class="variable">$(PWD)</span>/../<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line">EXTRA_CFLAGS += <span class="variable">$(DEBFLAGS)</span></span><br><span class="line">EXTRA_CFLAGS += -I<span class="variable">$(LDDINC)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line"><span class="comment"># call from kernel build system</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#scull-objs := main.o pipe.o access.o</span></span><br><span class="line"></span><br><span class="line">obj-m:= hello.o</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">KERNELDIR ?= /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line">PWD       := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions</span><br><span class="line"></span><br><span class="line">depend .depend dep:</span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(EXTRA_CFLAGS)</span> -M *.c &gt; .depend</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (.depend,<span class="variable">$(<span class="built_in">wildcard</span> .depend)</span>)</span><br><span class="line"><span class="keyword">include</span> .depend</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="kernel" scheme="https://www.colins110.cn/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>centos获取内核源码</title>
    <link href="https://www.colins110.cn/2020/03/08/centos%E8%8E%B7%E5%8F%96%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81/"/>
    <id>https://www.colins110.cn/2020/03/08/centos获取内核源码/</id>
    <published>2020-03-08T09:47:16.000Z</published>
    <updated>2020-03-08T09:55:03.860Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>参考<a href="https://wiki.centos.org/HowTos/I_need_the_Kernel_Source" target="_blank" rel="noopener">centos wiki</a></p><ol><li><p>常见编译目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[user@host]$ mkdir -p ~/rpmbuild/&#123;BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS&#125;</span><br><span class="line">[user@host]$ <span class="built_in">echo</span> <span class="string">'%_topdir %(echo $HOME)/rpmbuild'</span> &gt; ~/.rpmmacros</span><br></pre></td></tr></table></figure></li><li><p>安装必要的工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@host]<span class="comment"># yum install asciidoc audit-libs-devel bash bc binutils binutils-devel bison diffutils elfutils</span></span><br><span class="line">[root@host]<span class="comment"># yum install elfutils-devel elfutils-libelf-devel findutils flex gawk gcc gettext gzip hmaccalc hostname java-devel</span></span><br><span class="line">[root@host]<span class="comment"># yum install m4 make module-init-tools ncurses-devel net-tools newt-devel numactl-devel openssl</span></span><br><span class="line">[root@host]<span class="comment"># yum install patch pciutils-devel perl perl-ExtUtils-Embed pesign python-devel python-docutils redhat-rpm-config</span></span><br><span class="line">[root@host]<span class="comment"># yum install rpm-build sh-utils tar xmlto xz zlib-devel</span></span><br></pre></td></tr></table></figure></li><li><p>安装包含源码的rpm包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[user@host]$ rpm -i http://vault.centos.org/7.7.1908/updates/Source/SPackages/kernel-3.10.0-1062.12.1.el7.src.rpm 2&gt;&amp;1 | grep -v exist</span><br></pre></td></tr></table></figure></li></ol><p>可以使用<code>cat /etc/redhat-release</code>和<code>uname -r</code>确定要安装的内核源码。在线安装比较慢，可以到<a href="http://vault.centos.org" target="_blank" rel="noopener">http://vault.centos.org</a>下载后安装。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="kernel" scheme="https://www.colins110.cn/categories/kernel/"/>
    
    
      <category term="内核" scheme="https://www.colins110.cn/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>centos安装chacha20</title>
    <link href="https://www.colins110.cn/2020/02/08/centos%E5%AE%89%E8%A3%85chacha20/"/>
    <id>https://www.colins110.cn/2020/02/08/centos安装chacha20/</id>
    <published>2020-02-08T08:01:32.000Z</published>
    <updated>2020-02-08T08:04:45.342Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum install m2crypto gcc -y</span><br><span class="line">wget https://download.libsodium.org/libsodium/releases/libsodium-1.0.18.tar.gz</span><br><span class="line">tar zxf libsodium-1.0.18.tar.gz</span><br><span class="line"><span class="built_in">cd</span> libsodium-1.0.18</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"include ld.so.conf.d/*.conf"</span> &gt; /etc/ld.so.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"/lib"</span> &gt;&gt; /etc/ld.so.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"/usr/lib64"</span> &gt;&gt; /etc/ld.so.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"/usr/local/lib"</span> &gt;&gt; /etc/ld.so.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="linux" scheme="https://www.colins110.cn/categories/linux/"/>
    
    
      <category term="centos" scheme="https://www.colins110.cn/tags/centos/"/>
    
      <category term="chacha20" scheme="https://www.colins110.cn/tags/chacha20/"/>
    
  </entry>
  
  <entry>
    <title>[转]详解LMA&amp;VMA(浅显易懂)</title>
    <link href="https://www.colins110.cn/2020/02/07/%E8%BD%AC-%E8%AF%A6%E8%A7%A3LMA-VMA-%E6%B5%85%E6%98%BE%E6%98%93%E6%87%82/"/>
    <id>https://www.colins110.cn/2020/02/07/转-详解LMA-VMA-浅显易懂/</id>
    <published>2020-02-07T07:41:43.000Z</published>
    <updated>2020-02-07T07:43:09.627Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>关于LMA和VMA，这个问题，有点点小复杂，不过，此处，我会把我的理解，尽量通过通俗的方式解释出来，以方便理解。当然，鄙人水平有限，难免有错，希望各位批评指正。</p><p>一般提及LMA和VMA，多数情况都是和ld，链接器相关的。<br>在了解这两个名词的详细含义之前，有些基本知识和前提要说一下：<br>［基础知识］<br>1。从你写的源代码到执行你的程序，一般经历了这几个过程：<br>源代码编辑 -&gt; 编译 -&gt; 链接 -&gt; 装载 -&gt; 执行<br>2。编译，简单说就是用编译工具，将你的源码，变成可以执行的二进制代码，也叫做目标文件，当然只是对应某一种硬件平台，比如此处我用的是Intel的X86系列的CPU，编译出来的，就是针对X86的二进制代码。<br>3。链接就是，将多个目标文件合并为一个目标文件，称作可执行文件。<br>4。每个目标文件都包含一连串的section，最常见，最基础的至少有：<br>.text，代码段，就是CPU要运行的指令代码；<br>.data，数据段，程序中包含的一些数据，放在这个段里；<br>.bss，未初始化段，记录了程序里有哪些未初始化的变量，就相当于只记录对应的名字，留着程序运行前去初始化为0，所以，此处并不占用具体空间。打个比方就是，只记录人名，没有人站在这里占地方，而对应的.text和.data段，都是既有人名（函数或者变量名）,又占对应的地方（包含具体空间记录到底是什么指令代码和数据的数值是多少）。<br>5。section一般可以分为loadable与allocatable.<br>通俗点说就是：<br>loadable，可加载，就是，原先目标文件里面包含对应的代码或数据，所以，装载器要把这些内容，load到对应的地址，以便程序可以运行；<br>而allocatable，可分配的，最简单理解就是上面提到的.bss段，那里记录了人名，到时候，你要给这些人名分配空间给你站的地方，对应着也就是变量所要占用的具体内存空间了。<br>其他还有既不是loadbale的，也不是allocatable的，比如只存储debug信息的段，此处不多解释。<br>［前提］<br>程序已经编译好了，有了一个可执行文件，也叫目标文件，二进制文件，才会有后面的把程序装载，运行的事情。</p><p>看完了基础知识和前提，再说我们此处的主题，才能更加清楚是咋回事：<br>对于目标文件中的loadable或allocatable的section，其都有两个地址：VMA 和 LMA 。<br>知道了其来由，再看具体解释：<br>［LMA 详解］<br>LMA的英文原版解释：<br>LMA（Load Memory Address）： the address at which the section will be loaded.<br>什么是Load Memory Address，内存装载地址呢? 此处，单单从名字上，我们就可以看出几层意思：<br>1。load，装载<br>为何要装载呢？ 因为，如果想要使你的程序（即经历过，由你的源码，通过编译器的编译，链接器的链接，形成的那个可执行文件），能在内存里面运行，那么肯定涉及到一点，就是，有人，把你的这个程序，<br>，从此处常见的存储器硬盘里面，搬到内存里面去了，然后才有可能运行。而这里的装载，就是对应这个意思。就是把程序，从硬盘里面，装载Load，到内存里面去了。<br>对应地，放到内存哪里去了呢？就是LMA，Load Memory Address，就是把你的程序中的对应的内容，详细点说就是，把其中的.text代码段，.data数据段等内容，搬到，也就是copy拷贝到，内存的LMA地址处了。<br>2。Memory，内存<br>上面已经解释了，这里再多说几句。<br>程序运行的本质，就是CPU读取到指令，然后执行。这里就涉及到，如果想要你的程序运行，<br>首先，你应该把对应的指令，放到合适的地方，CPU 才能读到，才能执行。<br>此处合适的地方，有人想到，直接放到硬盘这里，CPU过来读取，然后执行不就可以了吗，还不用这么麻烦地将（指令）代码搬来搬去的，多省事。但是实际上，系统就是这么“笨”地搬来搬去，原因在于，从硬盘上直接读取指令，速度比直接从内存，一般PC 上是各种类型的RAM，比如DDR，此处统称为Memory/内存，<br>要慢很多倍，所以，系统才会不嫌弃麻烦，把代码拷贝到内存里面去，然后从内存里面读取指令，然后执行，这样效率会高很多。<br>所以，此处简单说就是，为了总体效率，对于普通系统，比如PC，程序的执行都是在Memory，内存里面执行的。</p><p>因此，用一句话总结就是：<br>代码被装载到内存的某个地方，那个地方的地址，就是LMA 。</p><p>［VMA 详解］<br>英文解释：<br>VMA（Virtual Memory Address）：the address the section will have when the output file is run;<br>那啥是虚拟内存地址呢？简单说就是，你程序运行时候的所对应的地址。<br>此处所谓的虚拟，一般来说，指的是启用了MMU之后，才有了虚拟地址和实地址。<br>此处，我们可以简单的理解为，就是内存的实际地址即可。<br>程序运行前，要把程序的内容，拷贝到对应的内存地址处，然后才能运行的。<br>因此，一句话总结就是：<br>代码要运行的时候，此时对应的地址，就是VMA。</p><p>［理解此句：在多数情况下，LMA和VMA是相等的］<br>这句话，说白了，可以（武断地）这么理解：<br>如果是普通PC电脑，也就是上面说的，大多数情况下，那么LMA和VMA是一样的，也就是，程序被加载到内存的什么地方，也就在什么地方运行。<br>如果是嵌入式系统，也就是相对的“少数情况”，LMA和VMA不一样。而其中最常见的一种情况就是，<br>程序被放到ROM中，比如设置为只读的Nor Flash中，也就是LMA的地址是Nor Flash的地址，<br>此如随便举例为0x10000000，而程序要运行时候的地址是内存地址，比如0x30000000,也就是VMA 是0x30000000，这时候，就要我们自己保证，在程序运行之前，把自己的程序，从LMA＝0x10000000拷贝到VMA＝0x3000000处，然后程序才可以正常运行。</p><p>有人会问，反正对于ROM来说，CPU 也是可以直接从ROM里面读取代码，然后运行的。为何还要前面提到的，弄个LMA 和VMA不同，搬来搬去的呢？因为ROM，顾名思义，是只读的，只能读取，不能写入的。<br>而程序中的代码段，由于只是被读取，不涉及到修改写入，是没有问题的。但是对于数据段和bss位初始化段来说，里面的所有的程序的变量，多数都是在运行的时候，不仅要读取，而且要被修改成新的值，然后写入新的值的，所以，如果还是放到ROM里面，就没法修改写入了。<br>而且，另一个原因是，CPU从ROM，比如常见的Nor Flash中读取代码的速度，要远远小于从RAM，比如常见的SDRAM，中读取的速度，所以，才会牵扯到将代码烧写到ROM里面，然后代码的最开始，将此部分程序reaload，重载，也就是从此处的ROM的地址，即LMA，重新拷贝到SDRAM中去，也就是VMA的地方，然后从那里运行。</p><p>［后记］<br>关于LMA 和 VMA：<br>Linker，链接器的作用：<br>1。将LMA写到（可执行的）二进制文件里面去<br>2。解析符号。即，把不同的符号，根据符号表中的信息，转换成对应的地址。此处只涉及VMA，即程序运行时候的地址。</p><p>Loader，装载器的作用：<br>1。从二进制文件中读出对应的段的信息，比如text，data，bss等段的信息，<br>将内容拷贝到对应的LMA的地址处。此谓，装载（对应内容）到装载地址（LMA）。<br>2。如果发现VMA!=LMA, 即 程序运行时候的地址，和刚刚把程序内容拷贝到的地址LMA，两者不一样，<br>那么就要把对应的内容，此处主要是data，数据段的内容，从刚刚装载到的位置，LMA处，拷贝到VMA处，<br>这样，程序运行的时候，才能够在执行的时候，找到对应的VMA处的变量，才能找到对应的值，程序才能正常运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="6.828" scheme="https://www.colins110.cn/categories/6-828/"/>
    
    
      <category term="elf" scheme="https://www.colins110.cn/tags/elf/"/>
    
  </entry>
  
  <entry>
    <title>[转]A20地址线问题</title>
    <link href="https://www.colins110.cn/2020/02/06/%E8%BD%AC-A20%E5%9C%B0%E5%9D%80%E7%BA%BF%E9%97%AE%E9%A2%98/"/>
    <id>https://www.colins110.cn/2020/02/06/转-A20地址线问题/</id>
    <published>2020-02-06T15:33:56.000Z</published>
    <updated>2020-02-06T15:43:30.558Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>A20地址线并不是打开保护模式的关键，只是在保护模式下，不打开A20地址线，你将无法访问到所有的内存（具体参考下面的第5点）</p><ol><li>用于80286与8086兼容</li><li>用于80286处于实模式下时，防止用户程序访问到100000h~10FFEFh之间的内存（高端内存）</li><li>8086模式，A20关闭的情况下，访问超过1MB内存时，会自动回卷</li><li>8086模式下，A20打开的情况下，访问超过1MB内存，就真实的访问</li><li>保护模式下，A20关闭（始终为0），则用户的地址只能是：0 - (1MB-1), 2 - (3MB-1), 4 - (5MB-1)，我们可以这样设想，A20为个位数（以1MB为单位），如果它始终为0，你永远不可能让这个数变成奇数。</li><li>保护模式下，A20开启，则可以访问全地址，没有奇偶MB的问题。</li></ol><p><strong>调用BIOS中断就可以实现A20 Gate的控制功能。</strong><br>这个BIOS中断为 INT 15h,AX=2401h。被称为Fast A20。</p><p><strong>下面转载一篇文档</strong>:<br><a href="https://wenku.baidu.com/view/b673e3360b4c2e3f57276369.html" target="_blank" rel="noopener">A20地址线问题</a></p><p>很多稀奇古怪的东西都是由于系统升级时，为了保持向下兼容而产生的，A20Gate就是其中之一。</p><p>在8086/8088中，只有20根地址总线，所以可以访问的地址是2^20=1M，但由于8086/8088是16位地址模式，能够表示的地址范围是0-64K，所以为了在8086/8088下能够访问1M内存，Intel采取了分段的模式：16位段基地址:16位偏移。其绝对地址计算方法为：16位基地址左移4位+16位偏移=20位地址。</p><p>但这种方式引起了新的问题，通过上述分段模式，能够表示的最大内存为：FFFFh:FFFFh=FFFF0h+FFFFh=10FFEFh=1M+64K-16Bytes（1M多余出来的部分被称做高端内存区HMA）。但8086/8088只有20位地址线，如果访问100000h~10FFEFh之间的内存，则必须有第21根地址线。所以当程序员给出超过1M（100000H-10FFEFH）的地址时，系统并不认为其访问越界而产生异常，而是自动从重新0开始计算，也就是说系统计算实际地址的时候是按照对1M求模的方式进行的，这种技术被称为wrap-around。</p><p>到了80286，系统的地址总线发展为24根，这样能够访问的内存可以达到2^24=16M。Intel在设计80286时提出的目标是，在实模式下，系统所表现的行为应该和8086/8088所表现的完全一样，也就是说，在实模式下，80286以及后续系列，应该和8086/8088完全兼容。但最终，80286芯片却存在一个BUG：如果程序员访问100000H-10FFEFH之间的内存，系统将实际访问这块内存，而不是象过去一样重新从0开始。</p><p>为了解决上述问题，IBM使用键盘控制器上剩余的一些输出线来管理第21根地址线（从0开始数是第20根），被称为A20Gate：如果A20 Gate被打开，则当程序员给出100000H-10FFEFH之间的地址的时候，系统将真正访问这块内存区域；如果A20Gate被禁止，则当程序员给出100000H-10FFEFH之间的地址的时候，系统仍然使用8086/8088的方式。绝大多数IBM PC兼容机默认的A20Gate是被禁止的。由于在当时没有更好的方法来解决这个问题，所以IBM使用了键盘控制器来操作A20 Gate，但这只是一种黑客行为，毕竟A20Gate和键盘操作没有任何关系。在许多新型PC上存在着一种通过芯片来直接控制A20 Gate的BIOS功能。从性能上，这种方法比通过键盘控制器来控制A20Gate要稍微高一点。</p><p>上面所述的内存访问模式都是实模式，在80286以及更高系列的PC中，即使A20Gate被打开，在实模式下所能够访问的内存最大也只能为10FFEFH，尽管它们的地址总线所能够访问的能力都大大超过这个限制。为了能够访问10FFEFH以上的内存，则必须进入保护模式。（其实所谓的实模式，就是8086/8088的模式，这种模式存在的唯一理由就是为了让旧的程序能够继续正常的运行在新的PC体系上）</p><ol><li>A20 Gate inProtected Mode</li></ol><p>从80286开始，系统出现了一种新的机制，被称为保护模式。到了80386，保护模式得到了进一步的完善和发展，并且对于80386以后的芯片，保护模式的变化就非常小了。</p><p>我们在上一节已经谈到，如果要访问更多的内存，则必须进入保护模式，那么，在保护模式下，A20Gate对于内存访问有什么影响呢？</p><p>为了搞清楚这一点，我们先来看一看A20的工作原理。A20，从它的名字就可以看出来，其实它就是对于20-bit（从0开始数）的特殊处理(也就是对第21根地址线的处理)。如果A20Gate被禁止，对于80286来说，其地址为24bit，其地址表示为EFFFFF；对于80386极其随后的32-bit芯片来说，其地址表示为FFEFFFFF。这种表示的意思是如果A20Gate被禁止，则其第20-bit在CPU做地址访问的时候是无效的，永远只能被作为0；如果A20 Gate被打开，则其第20-bit是有效的，其值既可以是0，又可以是1。</p><p>所以，在保护模式下，如果A20Gate被禁止，则可以访问的内存只能是奇数1M段，即1M,3M,5M…，也就是00000-FFFFF,200000-2FFFFF,300000-3FFFFF…。如果A20 Gate被打开，则可以访问的内存则是连续的。</p><ol start="2"><li>How to Enable A20Gate</li></ol><p>多数PC都使用键盘控制器（8042芯片）来处理A20Gate。</p><p>从理论上讲，打开A20Gate的方法是通过设置8042芯片输出端口（64h）的2nd-bit，但事实上，当你向8042芯片输出端口进行写操作的时候，在键盘缓冲区中，或许还有别的数据尚未处理，因此你必须首先处理这些数据。</p><p>流程如下：<br>　1. 禁止中断；<br>　2. 等待，直到8042 Inputbuffer为空为止；<br>　3. 发送禁止键盘操作命令到8042Input buffer；<br>　4. 等待，直到8042 Inputbuffer为空为止；<br>　5. 发送读取8042 OutputPort命令；<br>　6. 等待，直到8042 Outputbuffer有数据为止；<br>　7. 读取8042 Outputbuffer，并保存得到的字节；<br>　8. 等待，直到8042 Inputbuffer为空为止；<br>　9. 发送Write 8042Output Port命令到8042 Input buffer；<br>　10. 等待，直到8042 Inputbuffer为空为止；<br>　11. 将从8042 OutputPort得到的字节的第2位置1（OR 2），然后写入8042 Input buffer；<br>　12. 等待，直到8042 Inputbuffer为空为止；<br>　13. 发送允许键盘操作命令到8042Input buffer；<br>　14. 打开中断。</p><p>下面代码是一个相关实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">enable_a20:</span><br><span class="line">sti</span><br><span class="line">callwait_input_empty</span><br><span class="line">movb $0xAD, %al</span><br><span class="line">outb $0x64 #disableKeyboard</span><br><span class="line">callwait_input_empty</span><br><span class="line">movb $0xD0, %al</span><br><span class="line">outb $0x64 #command-read 8042 output port</span><br><span class="line">callwait_output_full</span><br><span class="line">inb $0x60 # got thevalue of 8042 output port and save it</span><br><span class="line">pushb %al</span><br><span class="line">callwait_input_empty</span><br><span class="line">movb $0xD1, %al</span><br><span class="line">outb $0x64 #command-write 8042 output port</span><br><span class="line">callwait_input_empty</span><br><span class="line">popb %al</span><br><span class="line">orb $0x02, %al #enable A20 Gate</span><br><span class="line">outb $0x60</span><br><span class="line">callwait_input_empty</span><br><span class="line">movb $0xAE, %al</span><br><span class="line">outb $0x64 #enableKeyboard</span><br><span class="line">cli</span><br><span class="line">ret</span><br><span class="line">wait_input_empty:</span><br><span class="line">rp1: inb $0x64</span><br><span class="line">testb %al, 0x02</span><br><span class="line">jnz rp1</span><br><span class="line">ret</span><br><span class="line">wait_output_full:</span><br><span class="line">rp2: inb $0x64</span><br><span class="line">testb %al, 0x01</span><br><span class="line">jz rp2</span><br><span class="line">ret</span><br></pre></td></tr></table></figure></p><p>以上描述的是一种和IBMPC完全兼容的，通过键盘控制器控制A20 Gate的方法。但是，正象我们在前面所提到的，A20 Gate与键盘操作完全没有关系，IBM之所以将A20Gate的功能控制放在键盘控制器上，完全是一种为了弥补Intel 80286与Intel8086/8088不完全兼容的缺陷，而采取的Hacker行为，所以在许多新型PC上存在着一种通过芯片来直接控制A20 Gate的BIOS功能，我们在RealMode下只需要调用BIOS中断就可以实现A20 Gate的控制功能。<br>这个BIOS中断为 INT 15h, AX=2401h。被称为Fast A20。<br><code>movw $0x2401, %ax</code><br><code>int $0x15</code></p><ol start="3"><li>How to Detect ifA20 Gate has been Enabled?<br>我们在之前已经提到，如果A20Gate被打开了，则在实模式下，程序员可以直接访问100000H~10FFEFH之间的内存，如果A20Gate被禁止，则在实模式下，若程序员访问100000H~10FFEFH之间的内存，则会被硬件自动转换为0H~0FFEFH之间的内存，所以我们可以利用这个差异来检测A20Gate是否被打开。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># This routine testswhether or not A20 is enabled. If so, it</span><br><span class="line"># exits with zf = 0.</span><br><span class="line"># The memory addressused, 0x200, is the int $0x80 vector, which</span><br><span class="line"># should be safe.</span><br><span class="line">A20_TEST_ADDR =4*0x80</span><br><span class="line">A20_TEST_LOOPS = 3</span><br><span class="line">a20_test:</span><br><span class="line">pushw %cx</span><br><span class="line">pushw %ax</span><br><span class="line">xorw %cx, %cx</span><br><span class="line">movw %cx, %fs # Lowmemory</span><br><span class="line">decw %cx</span><br><span class="line">movw %cx, %gs # Highmemory area</span><br><span class="line">movw$A20_TEST_LOOPS, %cx</span><br><span class="line">movw%fs:(A20_TEST_ADDR), %ax</span><br><span class="line">pushw %ax</span><br><span class="line">a20_test_wait:</span><br><span class="line">incw %ax</span><br><span class="line">movw %ax,%fs:(A20_TEST_ADDR)</span><br><span class="line">call delay #Serialize and make delay constant</span><br><span class="line">cmpw%gs:(A20_TEST_ADDR+0x10), %ax</span><br><span class="line">loope a20_test_wait</span><br><span class="line">popw%fs:(A20_TEST_ADDR)</span><br><span class="line">popw %ax</span><br><span class="line">popw %cx</span><br><span class="line">ret </span><br><span class="line">delay:</span><br><span class="line">outb %al,$0x80</span><br><span class="line">ret</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="6.828" scheme="https://www.colins110.cn/categories/6-828/"/>
    
    
      <category term="操作系统" scheme="https://www.colins110.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>linux密钥登陆</title>
    <link href="https://www.colins110.cn/2020/02/06/linux%E5%AF%86%E9%92%A5%E7%99%BB%E9%99%86/"/>
    <id>https://www.colins110.cn/2020/02/06/linux密钥登陆/</id>
    <published>2020-02-06T08:51:39.000Z</published>
    <updated>2020-02-06T08:55:09.074Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>生成密钥: <code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code><br>发送公钥: <code>ssh-copy-id &lt;username&gt;@&lt;host&gt;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="linux" scheme="https://www.colins110.cn/categories/linux/"/>
    
    
      <category term="ssh密钥登陆" scheme="https://www.colins110.cn/tags/ssh%E5%AF%86%E9%92%A5%E7%99%BB%E9%99%86/"/>
    
  </entry>
  
  <entry>
    <title>OSTEP虚拟化</title>
    <link href="https://www.colins110.cn/2020/01/30/OSTEP%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    <id>https://www.colins110.cn/2020/01/30/OSTEP虚拟化/</id>
    <published>2020-01-30T08:48:36.000Z</published>
    <updated>2020-02-06T08:16:02.014Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h1><blockquote><p>进程:运行的程序(runing program)</p></blockquote><p>通常情况下，一台pc上需要同时运行多个进程，以便提供易用性。</p><blockquote><p>需要解决的问题：如何提供多个CPU的假象<br>-&gt;虚拟化CPU技术(分时复用CPU time sharing of CPU)</p></blockquote><p>底层机制(mechanisms eg.上下文切换)+上层策略(policies eg.进程调度策略) 实现分时复用</p><blockquote><p>进程的组成: 地址空间(包含指令和数据等)、寄存器(eg. IP、SP等)、持久存储设备</p></blockquote><blockquote><p>进程API:</p></blockquote><ul><li><strong>Create</strong>: An operating system must include some method to create new processes. When you type a command into the shell, or double-click on an application icon, the OS is invoked to create a new process to run the program you have indicated.</li><li><strong>Destroy</strong>: As there is an interface for process creation, systems also provide an interface to destroy processes forcefully. Of course, many processes will run and just exit by themselves when complete; when they don’t, however, the user may wish to kill them, and thus an interface to halt a runaway process is quite useful.</li><li><strong>Wait</strong>: Sometimes it is useful to wait for a process to stop running; thus some kind of waiting interface is often provided.</li><li><strong>Miscellaneous Control</strong>: Other than killing or waiting for a process, there are sometimes other controls that are possible. For example,most operating systems provide some kind of method to suspend a process (stop it from running for a while) and then resume it (continue it running).</li><li><strong>Status</strong>: There are usually interfaces to get some status information about a process as well, such as how long it has run for, or what state it is in.</li></ul><blockquote><p>进程创建: A Little More Detail</p></blockquote><p><img src="/2020/01/30/OSTEP虚拟化/1.png" alt=""></p><ol><li><p>从磁盘将程序加载到内存地址空间<br>早期操作系统: 一次全部加载指令和数据 -&gt; 现代操作系统: 懒加载，每次只加载进程运行时需要的部分指令和数据(paging和swapping技术)</p></li><li><p>分配stack空间(C语言中用于局部变量、函数参数、返回地址),操作系统还需要将main；函数参数填充到stack中(eg. argc&amp;argv)</p></li><li><p>分配heap(C语言中用于动态分配内存，malloc分配，free释放，heap大小根据请求动态增长)</p></li><li><p>I/O相关操作(eg. 在unix系统中，每个进程默认关联三个打开的文件描述符:标准输入、标准输出和标准出错，更多I/O相关内存位于持久化部分)</p></li></ol><blockquote><p>进程状态</p></blockquote><ul><li><strong>Running</strong>: In the running state, a process is running on a processor.This means it is executing instructions.</li><li><strong>Ready</strong>: In the ready state, a process is ready to run but for some reason the OS has chosen not to run it at this given moment.</li><li><strong>Blocked</strong>: In the blocked state, a process has performed some kind of operation that makes it not ready to run until some other event takes place. A common example: when a process initiates an I/O request to a disk, it becomes blocked and thus some other process can use the processor.<br><img src="/2020/01/30/OSTEP虚拟化/2.png" alt=""></li></ul><blockquote><p>操作系统数据结构</p></blockquote><p>Information an OS needs to track about each process in the xv6 kernel:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the registers xv6 will save and restore</span></span><br><span class="line"><span class="comment">// to stop and subsequently restart a process</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> eip;</span><br><span class="line"><span class="keyword">int</span> esp;</span><br><span class="line"><span class="keyword">int</span> ebx;</span><br><span class="line"><span class="keyword">int</span> ecx;</span><br><span class="line"><span class="keyword">int</span> edx;</span><br><span class="line"><span class="keyword">int</span> esi;</span><br><span class="line"><span class="keyword">int</span> edi;</span><br><span class="line"><span class="keyword">int</span> ebp;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// the different states a process can be in</span></span><br><span class="line"><span class="keyword">enum</span> proc_state &#123; UNUSED, EMBRYO, SLEEPING,</span><br><span class="line">RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"><span class="comment">// the information xv6 tracks about each process</span></span><br><span class="line"><span class="comment">// including its register context and state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> *mem; <span class="comment">// Start of process memory</span></span><br><span class="line">uint sz; <span class="comment">// Size of process memory</span></span><br><span class="line"><span class="keyword">char</span> *kstack; <span class="comment">// Bottom of kernel stack</span></span><br><span class="line"><span class="comment">// for this process</span></span><br><span class="line"><span class="keyword">enum</span> proc_state state; <span class="comment">// Process state</span></span><br><span class="line"><span class="keyword">int</span> pid; <span class="comment">// Process ID</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span> <span class="comment">// Parent process</span></span><br><span class="line"><span class="keyword">void</span> *chan; <span class="comment">// If !zero, sleeping on chan</span></span><br><span class="line"><span class="keyword">int</span> killed; <span class="comment">// If !zero, has been killed</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span> <span class="comment">// Open files</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span> <span class="comment">// Current directory</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span> <span class="comment">// Switch here to run process</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span> <span class="comment">// Trap frame for the</span></span><br><span class="line"><span class="comment">// current interrupt</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><blockquote><p>一些术语：</p></blockquote><ul><li>The <strong>process</strong> is the major OS abstraction of a running program. At any point in time, the process can be described by its state: the contents of memory in its <strong>address space</strong>, the contents of CPU registers (including the <strong>program counter</strong> and <strong>stack pointer</strong>, among others),and information about I/O (such as open files which can be read or written).</li><li>The <strong>process API</strong> consists of calls programs can make related to processes. Typically, this includes creation, destruction,and other useful calls.</li><li>Processes exist in one of many different <strong>process states</strong>, including running, ready to run, and blocked. Different events (e.g., getting scheduled or descheduled, or waiting for an I/O to complete) transition a process from one of these states to the other.</li><li>A <strong>process list</strong> contains information about all processes in the system. Each entry is found in what is sometimes called a <strong>process control block (PCB)</strong>, which is really just a structure that contains information about a specific process.</li></ul><h1 id="进程API-实用内容"><a href="#进程API-实用内容" class="headerlink" title="进程API (实用内容)"></a>进程API (实用内容)</h1><p>//todo</p><h1 id="底层机制-Limited-Direct-Execution"><a href="#底层机制-Limited-Direct-Execution" class="headerlink" title="底层机制: Limited Direct Execution"></a>底层机制: Limited Direct Execution</h1><p>虚拟化CPU-&gt;同时运行多个进程(的假象)<br>idea: 分时复用CPU<br>challenges:</p><ol><li>performance : 高性能</li><li>control : OS保留控制能力</li></ol><p>实现: 硬件支持+软件实现</p><blockquote><p>基本技术: 限制直接执行(Limited Direct Execution)</p></blockquote><p><img src="/2020/01/30/OSTEP虚拟化/3.png" alt=""></p><p>the problem without “Limited”:</p><ol><li>限制操作</li><li>进程切换</li></ol><p>problem 1 : Restricted Operations<br>通过系统调用限制特权指令的执行：<br>即中断机制<br><img src="/2020/01/30/OSTEP虚拟化/4.png" alt=""></p><p>problem 2 : Switching Between Processes</p><ol><li>A Cooperative Approach: Wait For System Calls<br>通过系统调用陷入内核</li><li>A Non-Cooperative Approach: The OS Takes Control<br>时钟中断:使内核获得CPU控制</li></ol><p><img src="/2020/01/30/OSTEP虚拟化/5.png" alt=""></p><p>由时钟中断构造的进程切换有两次寄存器的保存和恢复，第一次发生在时钟中断发生时，由硬件将<code>user registers</code>保存到进程内核栈中，第二次发生在操作系统进行进程切换时，软件将<code>kernel registers</code>保存到进程控制块中。</p><blockquote><p>处理中断/陷入时发生中断/陷入<br>并行部分将做详细讨论: 主要是 关中断和锁机制</p></blockquote><p>上下文切换(context switch) -&gt; 进程切换</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.colins110.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="OSTEP" scheme="https://www.colins110.cn/tags/OSTEP/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu16.04配置tpcc-mysql</title>
    <link href="https://www.colins110.cn/2019/04/08/ubuntu16-04%E9%85%8D%E7%BD%AEtpcc-mysql/"/>
    <id>https://www.colins110.cn/2019/04/08/ubuntu16-04配置tpcc-mysql/</id>
    <published>2019-04-08T04:10:47.000Z</published>
    <updated>2019-04-08T07:52:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://github.com/Percona-Lab/tpcc-mysql" target="_blank" rel="noopener">项目地址</a>\</p><ol><li><p>安装mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install mysql-server</span><br><span class="line">$ sudo apt install libmysqlclient-dev  <span class="comment">#解决mysql_config缺失问题</span></span><br></pre></td></tr></table></figure></li><li><p>编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> src</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure></li><li><p>配置tpcc-mysql</p><ul><li><p>创建数据库tpcctest</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mysqladmin create tpcctest -p</span><br></pre></td></tr></table></figure></li><li><p>创建表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysql tpcctest &lt; create_table.sql -u root -p</span><br></pre></td></tr></table></figure></li><li><p>创建indexes和FK</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysql tpcctest &lt; add_fkey_idx.sql -u root -p</span><br></pre></td></tr></table></figure></li><li><p>填充数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./tpcc_load -h 127.0.0.1 -d tpcctest -u root -p <span class="string">"123"</span> -w 100</span><br></pre></td></tr></table></figure></li></ul></li><li><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./tpcc_start -h 127.0.0.1 -p 3306 -d tpcctest -u root -p <span class="string">"123"</span> -c 32 -r 10 -l 10800</span><br></pre></td></tr></table></figure></li></ol><p>参考：</p><ol><li><a href="https://github.com/Percona-Lab/tpcc-mysql" target="_blank" rel="noopener">项目主页</a></li><li><a href="https://blog.csdn.net/jswangchang/article/details/81317741" target="_blank" rel="noopener">TPCC-Mysql 测试</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="benchmark" scheme="https://www.colins110.cn/categories/benchmark/"/>
    
    
      <category term="tpcc-mysql" scheme="https://www.colins110.cn/tags/tpcc-mysql/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu16.04配置SPARK-bench</title>
    <link href="https://www.colins110.cn/2019/04/07/ubuntu16-04%E9%85%8D%E7%BD%AESPARK-bench/"/>
    <id>https://www.colins110.cn/2019/04/07/ubuntu16-04配置SPARK-bench/</id>
    <published>2019-04-07T13:31:58.000Z</published>
    <updated>2019-04-08T08:13:21.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>先看官网:<a href="https://codait.github.io/spark-bench/" target="_blank" rel="noopener">直达链接</a><br>运行SPARK-bench需要配置java环境和spark环境。具体可以google。这里简单介绍一下。</p><blockquote><p>java环境配置</p><ol><li>下载jdk包：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">jdk8</a></li><li>解压文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xvf jdk-8u201-linux-x64.tar.gz</span><br><span class="line">$ sudo mkdir /usr/lib/jdk</span><br><span class="line">$ mv jdk1.8.0_201 /usr/lib/jdk/</span><br></pre></td></tr></table></figure></li></ol></blockquote><ol start="3"><li><p>配置环境变量<br>在/etc/profile添加以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#set java environment</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jdk/jdk1.8.0_201</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p> 如果只是对当前用户更改环境变量，可以在<code>~/.bashrc</code>中修改。</p></li></ol><blockquote><p>spark环境配置</p><ol><li>下载spark：<a href="http://spark.apache.org/downloads.html" target="_blank" rel="noopener">spark</a></li><li>解压文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xvf spark-2.4.1-bin-hadoop2.7.tgz</span><br><span class="line">$ sudo mkdir /usr/lib/spark</span><br><span class="line">$ sudo mv spark-2.4.1-bin-hadoop2.7 /usr/lib/spark/</span><br></pre></td></tr></table></figure></li></ol></blockquote><ol start="3"><li><p>配置环境变量<br>在/etc/profile添加以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#set spark environment</span></span><br><span class="line"><span class="built_in">export</span> SPARK_HOME=/usr/lib/spark/spark-2.4.1-bin-hadoop2.7</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;SPARK_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p> 如果只是对当前用户更改环境变量，可以在<code>~/.bashrc</code>中修改。</p></li></ol><blockquote><p>配置Spark-Bench</p><ol><li>下载spark-bench：<a href="https://github.com/SparkTC/spark-bench/releases/latest" target="_blank" rel="noopener">releases page on Github</a></li><li>解压<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xvf spark-bench_2.3.0_0.4.0-RELEASE_99.tgz</span><br></pre></td></tr></table></figure></li></ol></blockquote><ol start="3"><li>配置环境变量：<ul><li>第一种方式：设置bash环境变量<br>  修改<code>bin/spark-bench-env.sh</code>文件中的<code>SPARK_HOME</code> 和 <code>SPARK_MASTER_HOST</code>变量。</li><li>第二种方式：修改配置文件(推荐)<br>参考<a href="https://codait.github.io/spark-bench/users-guide/installation/" target="_blank" rel="noopener">官方文档</a></li></ul></li><li>运行</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="benchmark" scheme="https://www.colins110.cn/categories/benchmark/"/>
    
    
      <category term="SPARK-bench" scheme="https://www.colins110.cn/tags/SPARK-bench/"/>
    
  </entry>
  
  <entry>
    <title>office2016零售版转VOL版</title>
    <link href="https://www.colins110.cn/2019/03/27/office2016%E9%9B%B6%E5%94%AE%E7%89%88%E8%BD%ACVOL%E7%89%88/"/>
    <id>https://www.colins110.cn/2019/03/27/office2016零售版转VOL版/</id>
    <published>2019-03-27T10:40:23.000Z</published>
    <updated>2019-04-17T05:22:47.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>下载<a href="https://www.colins110.cn/download/Office2016-vol.bat">脚本</a><br>管理员下运行脚本，选择要转换的选项，填入秘钥：XQNVK-8JYDB-WJ9W3-YJ8YR-WFG99<br><img src="/2019/03/27/office2016零售版转VOL版/1.png" alt=""></p><p><a href="https://github.com/Wind4/vlmcsd/tree/gh-pages" target="_blank" rel="noopener">各版本vol秘钥</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="tools" scheme="https://www.colins110.cn/categories/tools/"/>
    
    
      <category term="office" scheme="https://www.colins110.cn/tags/office/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu18.04配置PARSEC benchmark</title>
    <link href="https://www.colins110.cn/2019/03/21/ubuntu18-04%E9%85%8D%E7%BD%AEPARSEC-benchmark/"/>
    <id>https://www.colins110.cn/2019/03/21/ubuntu18-04配置PARSEC-benchmark/</id>
    <published>2019-03-21T13:49:01.000Z</published>
    <updated>2019-04-16T07:43:47.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="http://parsec.cs.princeton.edu/parsec3-doc.htm" target="_blank" rel="noopener">官方文档</a></p><ol><li><p>安装必要环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install make gcc g++</span><br></pre></td></tr></table></figure></li><li><p>下载PARSEC 3.0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://parsec.cs.princeton.edu/download/3.0/parsec-3.0.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf parsec-3.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> parsec-3.0</span><br></pre></td></tr></table></figure></li><li><p>运行脚本配置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> env.sh</span><br></pre></td></tr></table></figure></li><li><p>编译/运行/卸载 benchmarks</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">parsecmgmt -a build -p streamcluster <span class="comment">#编译streamcluster</span></span><br><span class="line">parsecmgmt -a run -p streamcluster <span class="comment">#运行streamcluster，默认使用test数据集</span></span><br><span class="line">parsecmgmt -a fulluninstall -p streamcluster <span class="comment">#卸载streamcluster</span></span><br><span class="line"><span class="comment">#Note that it may take several hours depending on your machine</span></span><br><span class="line">parsecmgmt -a build -p all <span class="comment">#编译所有的bench</span></span><br><span class="line">parsecmgmt -a run -p all <span class="comment">#运行所有的bench</span></span><br><span class="line">parsecmgmt -a fulluninstall -p streamcluster <span class="comment">#卸载所有的bench</span></span><br><span class="line"></span><br><span class="line">parsecmgmt -a info -p streamcluster <span class="comment">#查看streamcluster的信息，包括各种input数据集</span></span><br><span class="line">parsecmgmt -a run -p streamcluster -i native <span class="comment">#使用native数据集测试</span></span><br></pre></td></tr></table></figure></li></ol><p>数据集可以参考官方介绍:<br><img src="/2019/03/21/ubuntu18-04配置PARSEC-benchmark/input_sets.PNG" alt="input sets"><br>注意，有的bench可能不止上述的输入，具体使用info选项查看。</p><p>环境配置：<br>first，建议只装自己需要的且一个一个benchmark 装，除非很有耐心。<br>1.blackscholes : 首先安装sudo apt-get install m4<br>2.dedup : encoder.c 增加 #include &lt;sys/stat.h&gt;   <strong>注：我在测试得时候发现 这个方法失效，暂时没有编译出来</strong><br>3.vips：缺少zlib sudo apt-get install  zlib1g-dev 然后gettext 错误 sudo apt-get install libgtk2.0-dev  <a href="http://www.cnblogs.com/soli/archive/2008/01/14/1039010.html" target="_blank" rel="noopener">http://www.cnblogs.com/soli/archive/2008/01/14/1039010.html</a><br>4.raytrace:mesa 安装xorg-dev<br>5.facesim:3.0中缺少input，可在有用网址2中找到</p><p>第一遍装的时候感觉很费劲，这次好多了，但也没有发现多少缺少的。只装了blackscholes，bodytrace，canneal，dedup，facesim，raytrace，streamcluster，swaptions，vips,x264.<br>有用的网址：<a href="http://parsec.cs.princeton.edu/parsec3-doc.htm" target="_blank" rel="noopener">http://parsec.cs.princeton.edu/parsec3-doc.htm</a><br><a href="http://www.multi2sim.org/svn/m2s-bench-parsec-2.1/facesim/data-small/Face_Data/Eftychis_840k/" target="_blank" rel="noopener">http://www.multi2sim.org/svn/m2s-bench-parsec-2.1/facesim/data-small/Face_Data/Eftychis_840k/</a></p><p>参考：<br><a href="http://blog.sina.com.cn/s/blog_6778e105010186ny.html" target="_blank" rel="noopener">ubuntu 12.04 编译 parsec3.0 </a><br><a href="https://parsec.cs.princeton.edu/download/tutorial/3.0/parsec-tutorial.pdf" target="_blank" rel="noopener">parsec-tutorial</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="benchmark" scheme="https://www.colins110.cn/categories/benchmark/"/>
    
    
      <category term="PARSEC" scheme="https://www.colins110.cn/tags/PARSEC/"/>
    
  </entry>
  
  <entry>
    <title>DaCapo benchmark环境搭建</title>
    <link href="https://www.colins110.cn/2019/03/19/DaCapo-benchmark%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://www.colins110.cn/2019/03/19/DaCapo-benchmark环境搭建/</id>
    <published>2019-03-19T07:06:42.000Z</published>
    <updated>2019-03-19T13:20:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>虚拟化性能测试需要使用benchmark测试，这里使用了DaCapo来实现。<br>DaCapo基于java编写，需要java运行时环境，所以需要配置java环境。<br><a href="http://dacapobench.org/" target="_blank" rel="noopener">项目主页</a></p><ol><li><p>在配置环境之前需要将host的hugepage关闭，运行一下命令关闭：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash -c <span class="string">"echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled"</span></span><br></pre></td></tr></table></figure></li><li><p>在guest中配置java</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:webupd8team/java</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install oracle-java8-installer</span><br></pre></td></tr></table></figure><p> 使用<code>java --version</code>测试是否安装成功</p></li><li>下载DaCapo包<br>下载地址：<a href="https://sourceforge.net/projects/dacapobench/files/" target="_blank" rel="noopener">dacapo-9.12-MR1-bach.jar</a></li><li><p>常用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java -jar dacapo-9.12-MR1-bach.jar   <span class="comment">#获取指令使用信息</span></span><br><span class="line">java -jar dacapo-9.12-MR1-bach.jar -l   <span class="comment">#列出所有benchmark</span></span><br><span class="line">java -jar dacapo-9.12-MR1-bach.jar avrora（benchmark名)   <span class="comment">#运行相应benchmark</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#dacapo对每一个benchmark提供了三种不同大小的负载</span></span><br><span class="line">java -jar dacapo-9.12-MR1-bach.jar -s small avrora   <span class="comment">#以小负载运行benchmark</span></span><br><span class="line">java -jar dacapo-9.12-MR1-bach.jar -s default avrora   <span class="comment">#以默认负载运行benchmark</span></span><br><span class="line">java -jar dacapo-9.12-MR1-bach.jar -s large avrora   <span class="comment">#以大负载运行benchmark</span></span><br></pre></td></tr></table></figure><p>在不同负载下，同一个benchmark运行时间不同。benchmark相关的配置文件在文件夹dacapo-9.12-MR1-bach.jar/cnf中。<br>附件：<a href="https://www.colins110.cn/download/dacapo-oopsla-2006.pdf">《The DaCapo Benchmarks: Java Benchmarking Development and Analysis》</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="虚拟化" scheme="https://www.colins110.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="linux" scheme="https://www.colins110.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>[转]Linux内核高端内存</title>
    <link href="https://www.colins110.cn/2019/03/18/%E8%BD%AC-Linux%E5%86%85%E6%A0%B8%E9%AB%98%E7%AB%AF%E5%86%85%E5%AD%98/"/>
    <id>https://www.colins110.cn/2019/03/18/转-Linux内核高端内存/</id>
    <published>2019-03-18T06:23:49.000Z</published>
    <updated>2019-03-18T06:52:34.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="http://ilinuxkernel.com/?p=1013" target="_blank" rel="noopener">原文地址</a></p><h2 id="Linux内核地址映射模型"><a href="#Linux内核地址映射模型" class="headerlink" title="Linux内核地址映射模型"></a>Linux内核地址映射模型</h2><p><strong>x86 CPU</strong>采用了段页式地址映射模型。<strong>进程代码</strong>中的地址为逻辑地址，经过段页式地址映射后，才真正访问物理内存。<br>段页式机制如下图。<br><img src="/2019/03/18/转-Linux内核高端内存/1.png" alt="段页式机制"></p><h2 id="Linux内核地址空间划分"><a href="#Linux内核地址空间划分" class="headerlink" title="Linux内核地址空间划分"></a>Linux内核地址空间划分</h2><p>通常<strong>32位Linux内核</strong>地址空间划分0~3G为用户空间，3~4G为内核空间。注意这里是32位内核地址空间划分，64位内核地址空间划分是不同的。<br><img src="/2019/03/18/转-Linux内核高端内存/2.png" alt="linux内核地址空间划分"></p><h2 id="Linux内核高端内存的由来"><a href="#Linux内核高端内存的由来" class="headerlink" title="Linux内核高端内存的由来"></a>Linux内核高端内存的由来</h2><p>当内核模块代码或线程访问内存时，代码中的内存地址都为逻辑地址，而对应到真正的物理内存地址，需要地址一对一的映射，如逻辑地址0xc0000003对应的物理地址为0x3，0xc0000004对应的物理地址为0x4，… …，逻辑地址与物理地址对应的关系为</p><blockquote><p>物理地址 = 逻辑地址 – 0xC0000000</p></blockquote><p><img src="/2019/03/18/转-Linux内核高端内存/3.png" alt="地址映射"></p><p>假设按照上述简单的地址映射关系，那么内核逻辑地址空间访问为0xc0000000 ~ 0xffffffff，那么对应的物理内存范围就为0x0 ~ 0x40000000，即只能访问1G物理内存。若机器中安装8G物理内存，那么内核就只能访问前1G物理内存，后面7G物理内存将会无法访问，因为内核的地址空间已经全部映射到物理内存地址范围0x0 ~ 0x40000000。即使安装了8G物理内存，那么物理地址为0x40000001的内存，内核该怎么去访问呢？代码中必须要有内存逻辑地址的，0xc0000000 ~ 0xffffffff的地址空间已经被用完了，所以无法访问物理地址0x40000000以后的内存。</p><p>显然不能将内核地址空间0xc0000000 ~ 0xfffffff全部用来简单的地址映射。因此x86架构中将物理地址划分三部分：ZONE_DMA、ZONE_NORMAL和ZONE_HIGHMEM。ZONE_HIGHMEM即为高端内存，这就是内存高端内存概念的由来。</p><p>在x86结构中，三种类型的区域如下：</p><blockquote><p><strong>ZONE_DMA</strong>         内存开始的16MB<br><strong>ZONE_NORMAL</strong>       16MB~896MB<br><strong>ZONE_HIGHMEM</strong>      896MB ~ 结束</p></blockquote><p><img src="/2019/03/18/转-Linux内核高端内存/4.png" alt="地址空间划分"></p><h2 id="Linux内核高端内存的理解"><a href="#Linux内核高端内存的理解" class="headerlink" title="Linux内核高端内存的理解"></a>Linux内核高端内存的理解</h2><p>前面我们解释了高端内存的由来。 Linux将内核地址空间划分为三部分ZONE_DMA、ZONE_NORMAL和ZONE_HIGHMEM，高端内存HIGH_MEM地址空间范围为0xF8000000 ~ 0xFFFFFFFF（896MB～1024MB）。那么如内核是<strong>如何借助128MB高端内存地址空间是如何实现访问可以所有物理内存？</strong></p><p>当内核想访问高于896MB物理地址内存时，从0xF8000000 ~ 0xFFFFFFFF地址空间范围内找一段相应大小空闲的逻辑地址空间，借用一会。借用这段逻辑地址空间，建立映射到想访问的那段物理内存（即填充内核PTE页面表），<strong>临时用一会，用完后归还</strong>。这样别人也可以借用这段地址空间访问其他物理内存，实现了使用有限的地址空间，访问所有所有物理内存。如下图。<br><img src="/2019/03/18/转-Linux内核高端内存/5.png" alt="地址映射"><br>例如内核想访问2G开始的一段大小为1MB的物理内存，即物理地址范围为0x80000000 ~ 0x800FFFFF。访问之前先找到一段1MB大小的空闲地址空间，假设找到的空闲地址空间为0xF8700000 ~ 0xF87FFFFF，用这1MB的逻辑地址空间映射到物理地址空间0x80000000 ~ 0x800FFFFF的内存。映射关系如下：<br><img src="/2019/03/18/转-Linux内核高端内存/6.png" alt="映射关系"><br>当内核访问完0x80000000 ~ 0x800FFFFF物理内存后，就将0xF8700000 ~ 0xF87FFFFF内核线性空间释放。这样其他进程或代码也可以使用0xF8700000 ~ 0xF87FFFFF这段地址访问其他物理内存。<br>从上面的描述，我们可以知道<strong>高端内存的最基本思想</strong>：借一段地址空间，建立临时地址映射，用完后释放，达到这段地址空间可以循环使用，访问所有物理内存。<br>看到这里，不禁有人会问：万一有内核进程或模块一直占用某段逻辑地址空间不释放，怎么办？若真的出现的这种情况，则内核的高端内存地址空间越来越紧张，若都被占用不释放，则没有建立映射到物理内存都无法访问了。<br>在香港尖沙咀有些写字楼，洗手间很少且有门锁的。客户要去洗手间的话，可以向前台拿钥匙，方便完后，把钥匙归还到前台。这样虽然只有一个洗手间，但可以满足所有客户去洗手间的需求。要是某个客户一直占用洗手间、钥匙不归还，那么其他客户都无法上洗手间了。Linux内核高端内存管理的思想类似。</p><h2 id="Linux内核高端内存的划分"><a href="#Linux内核高端内存的划分" class="headerlink" title="Linux内核高端内存的划分"></a>Linux内核高端内存的划分</h2><p>内核将高端内存划分为3部分：VMALLOC_START~VMALLOC_END、KMAP_BASE~FIXADDR_START和FIXADDR_START~4G。<br><img src="/2019/03/18/转-Linux内核高端内存/7.png" alt="高端内存划分"><br>对于高端内存，可以通过 alloc_page() 或者其它函数获得对应的 page，但是要想访问实际物理内存，还得把 page 转为线性地址才行（为什么？想想 MMU 是如何访问物理内存的），也就是说，我们需要为高端内存对应的 page 找一个线性空间，这个过程称为高端内存映射。<br>对应高端内存的3部分，高端内存映射有三种方式：</p><ol><li>映射到”内核动态映射空间”（noncontiguous memory allocation）<br>这种方式很简单，因为通过 vmalloc() ，在”内核动态映射空间”申请内存的时候，就可能从高端内存获得页面（参看 vmalloc 的实现），因此说高端内存有可能映射到”内核动态映射空间”中。</li><li>持久内核映射（permanent kernel mapping）<br>如果是通过 alloc_page() 获得了高端内存对应的 page，如何给它找个线性空间？<br>内核专门为此留出一块线性空间，从 PKMAP_BASE 到 FIXADDR_START ，用于映射高端内存。在 2.6内核上，这个地址范围是 4G-8M 到 4G-4M 之间。这个空间起叫”内核永久映射空间”或者”永久内核映射空间”。这个空间和其它空间使用同样的页目录表，对于内核来说，就是 swapper_pg_dir，对普通进程来说，通过 CR3 寄存器指向。通常情况下，这个空间是 4M 大小，因此仅仅需要一个页表即可，内核通过来 pkmap_page_table 寻找这个页表。通过 kmap()，可以把一个 page 映射到这个空间来。由于这个空间是 4M 大小，最多能同时映射 1024 个 page。因此，对于不使用的的 page，及应该时从这个空间释放掉（也就是解除映射关系），通过 kunmap() ，可以把一个 page 对应的线性地址从这个空间释放出来。</li><li>临时映射（temporary kernel mapping）<br>内核在 FIXADDR_START 到 FIXADDR_TOP 之间保留了一些线性空间用于特殊需求。这个空间称为”固定映射空间”在这个空间中，有一部分用于高端内存的临时映射。</li></ol><p>这块空间具有如下特点：<br>（1）每个 CPU 占用一块空间<br>（2）在每个 CPU 占用的那块空间中，又分为多个小空间，每个小空间大小是 1 个page，每个小空间用于一个目的，这些目的定义在 kmap_types.h 中的 km_type 中。</p><p>当要进行一次临时映射的时候，需要指定映射的目的，根据映射目的，可以找到对应的小空间，然后把这个空间的地址作为映射地址。这意味着一次临时映射会导致以前的映射被覆盖。通过 kmap_atomic() 可实现临时映射。</p><h2 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h2><ol><li><p>用户空间（进程）是否有高端内存概念？<br>用户进程没有高端内存概念。只有在内核空间才存在高端内存。用户进程最多只可以访问3G物理内存，而内核进程可以访问所有物理内存。</p></li><li><p>64位内核中有高端内存吗？<br>目前现实中，64位Linux内核不存在高端内存，因为64位内核可以支持超过512GB内存。若机器安装的物理内存超过内核地址空间范围，就会存在高端内存。</p></li><li><p>用户进程能访问多少物理内存？内核代码能访问多少物理内存？<br>32位系统用户进程最大可以访问3GB，内核代码可以访问所有物理内存。<br>64位系统用户进程最大可以访问超过512GB，内核代码可以访问所有物理内存。</p></li><li><p>高端内存和物理地址、逻辑地址、线性地址的关系？<br>高端内存只和物理地址有关系，和线性地址、逻辑地址没有直接关系。</p></li><li><p>为什么不把所有的地址空间都分配给内核？<br>若把所有地址空间都给内存，那么用户进程怎么使用内存？怎么保证内核使用内存和用户进程不起冲突？</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="linux内核" scheme="https://www.colins110.cn/categories/linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="linux内核" scheme="https://www.colins110.cn/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>git设置和取消代理</title>
    <link href="https://www.colins110.cn/2019/03/08/git%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%8F%96%E6%B6%88%E4%BB%A3%E7%90%86/"/>
    <id>https://www.colins110.cn/2019/03/08/git设置和取消代理/</id>
    <published>2019-03-08T11:36:42.000Z</published>
    <updated>2019-03-08T11:44:35.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>查看当前代理设置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy</span><br><span class="line">git config --global https.proxy</span><br></pre></td></tr></table></figure></p><p>设置代理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy <span class="string">'http://127.0.0.1:1080'</span></span><br><span class="line">git config --global https.proxy <span class="string">'https://127.0.0.1:1080'</span></span><br><span class="line">git config --global http.proxy <span class="string">'socks5://127.0.0.1:1080'</span> </span><br><span class="line">git config --global https.proxy <span class="string">'socks5://127.0.0.1:1080'</span></span><br></pre></td></tr></table></figure></p><p>取消设置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="git" scheme="https://www.colins110.cn/categories/git/"/>
    
    
      <category term="git使用" scheme="https://www.colins110.cn/tags/git%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>台湾清华彭明辉教授的研究生手册(学习方法论)</title>
    <link href="https://www.colins110.cn/2019/03/08/%E5%8F%B0%E6%B9%BE%E6%B8%85%E5%8D%8E%E5%BD%AD%E6%98%8E%E8%BE%89%E6%95%99%E6%8E%88%E7%9A%84%E7%A0%94%E7%A9%B6%E7%94%9F%E6%89%8B%E5%86%8C-%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    <id>https://www.colins110.cn/2019/03/08/台湾清华彭明辉教授的研究生手册-学习方法论/</id>
    <published>2019-03-08T11:25:33.000Z</published>
    <updated>2019-03-08T11:27:38.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://www.colins110.cn/download/台湾清华彭明辉教授的研究生手册.pdf">原文地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="方法论" scheme="https://www.colins110.cn/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    
      <category term="方法论" scheme="https://www.colins110.cn/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu下KVM虚拟机创建</title>
    <link href="https://www.colins110.cn/2019/02/28/ubuntu%E4%B8%8BKVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9B%E5%BB%BA/"/>
    <id>https://www.colins110.cn/2019/02/28/ubuntu下KVM虚拟机创建/</id>
    <published>2019-02-28T03:01:27.000Z</published>
    <updated>2019-04-08T10:28:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>网上关于KVM虚拟机创建的文章有很多，但是都是只提供命令，没有解释。对于初学者很不友好，这里记录下我自己的实践。<br>因为我的服务器使用的是ubuntu16.04，所以以下操作都是基于此系统。<br>我是在windows下使用MobaXterm来连接我自己的服务器的，这里强力推荐这款软件，非常方便。</p><blockquote><p>以下代码’#’后的内容为注释<br>‘$’后为执行命令</p></blockquote><h2 id="验证主机是否支持硬件虚拟化"><a href="#验证主机是否支持硬件虚拟化" class="headerlink" title="验证主机是否支持硬件虚拟化"></a>验证主机是否支持硬件虚拟化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep svm <span class="comment"># AMD硬件</span></span><br><span class="line">cat /proc/cpuinfo | grep vmx <span class="comment"># Intel硬件</span></span><br></pre></td></tr></table></figure><p>svm是ADM的ADM-V虚拟化技术标识，全称secure virtual machine，vmx是Intel的硬件虚拟化技术VT-x，标识是vmx，全称为virtual machine extension。通过查询cpuinfo文件，可以知道硬件是否支持虚拟化。若返回结果中有svm或者vmx则说明硬件支持虚拟化。</p><h2 id="安装必要依赖"><a href="#安装必要依赖" class="headerlink" title="安装必要依赖"></a>安装必要依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install qemu-kvm libvirt-bin virtinst bridge-utils virt-viewer virt-manager</span><br></pre></td></tr></table></figure><ul><li>kvm:linux系统自带，已经编译进linux内核</li><li>qemu-kvm：KVM的设备模拟器，因为KVM只负责CPU和内存的虚拟化，独立无法完成整个系统的虚拟化，所以KVM开发者使用成熟的qemu来完成其他部件的虚拟化，qemu负责虚拟机的管理，kvm负责加速</li><li>libvirt：Libvirt是用于管理虚拟化平台的开源的API，后台程序和管理工具。它可以用于管理KVM、Xen、VMware ESX，QEMU和其他虚拟化技术</li><li>virtinst: 虚拟机创建（virt-install）和克隆工具（vrit-clone）等</li><li>birdge-utils: 用于桥接网卡的工具</li><li>virt-viewer：连接虚拟机屏幕的工具，需要桌面环境支持，使用mobaXterm可以远程使用x11图形界面，非常方便。</li><li>virt-manager：gui虚拟机管理工具，类似于windows上的vmware workstation</li></ul><h3 id="KVM管理工具的一些注解及一些实用工具"><a href="#KVM管理工具的一些注解及一些实用工具" class="headerlink" title="KVM管理工具的一些注解及一些实用工具"></a>KVM管理工具的一些注解及一些实用工具</h3><ul><li>libvirt：操作和管理KVM虚机的虚拟化API，使用C语言编写，可以由Python,Ruby, Perl, PHP, Java等语言调用。可以操作包括KVM，vmware，XEN，Hyper-v, LXC，virtualbox等 Hypervisor。</li><li>virsh：基于libvirt的命令行工具，后面需要大量使用</li><li>virt-v2v：虚机格式迁移工具，该工具与virt-sysprep都包含在包libguestfs-tools中，后面布署中会用到</li><li>virt-install：创建KVM虚机的命令行工具</li><li>virt-viewer：连接到虚拟机屏幕的工具，需要主机有桌面环境，该工具需要单独安装sudo apt-get install virt-viewer</li><li>virt-clone：虚机克隆工具</li><li>virt-top：类似于linux系统下的top命令，可以显示所有虚拟机CPU、内存等使用情况，该工具需要单独安装sudo apt-get install virt-top</li></ul><h2 id="虚拟机创建"><a href="#虚拟机创建" class="headerlink" title="虚拟机创建"></a>虚拟机创建</h2><p>默认情况下，在安装完上述环境后，会自动配置好一个默认的网络环境<code>default</code>,可以使用如下命令查看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo virsh net-list --all</span><br></pre></td></tr></table></figure></p><p>假如不小心通过brctl（用于管理桥接网络的工具）删除了default网络，可以通过重新加载预置的XML文件来恢复：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo virsh net-define /usr/share/libvirt/networks/default.xml  <span class="comment">#重新定义网络</span></span><br><span class="line">Network default defined from /usr/share/libvirt/networks/default.xml</span><br><span class="line">$ sudo virsh net-autostart default  <span class="comment">#设置default开机自动启动</span></span><br><span class="line">Network default marked as autostarted</span><br><span class="line">$ sudo virsh net-start default  <span class="comment">#启动网络default</span></span><br><span class="line">Network default started</span><br></pre></td></tr></table></figure></p><p>这里默认的配置是nat模式，即guestOS可以通过host上网，而在外部看不到guest。</p><p>为了让非root用户可以直接使用virsh命令管理虚拟机，需要将普通用户加入到kvm和libvirt用户组中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser &lt;youruser&gt; kvm</span><br><span class="line">$ sudo adduser &lt;youruser&gt; libvirtd</span><br></pre></td></tr></table></figure></p><p>centos 使用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gpasswd -a &lt;youruser&gt; kvm</span><br><span class="line">$ sudo gpasswd -a &lt;youruser&gt; libvirt</span><br></pre></td></tr></table></figure></p><p>这个时候重新登录就会使新的用户组成员生效了。</p><h2 id="使用virt-manager创建虚拟机"><a href="#使用virt-manager创建虚拟机" class="headerlink" title="使用virt-manager创建虚拟机"></a>使用virt-manager创建虚拟机</h2><p>新手推荐使用图形化界面创建虚拟机。使用MobaXterm连接服务器时原生支持x11，所以直接在shell中运行virt-manager就可以了，配置同vmware类似，这里就不多介绍了<br>注意:在centos 7 上使用virt-manager安装时，显示协议选择spice时，需要gtk支持：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install gtk3</span><br></pre></td></tr></table></figure></p><p>centos 7上安装的virsh的uri默认为qemu:///session,可以在用户目录下使用配置文件更改：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/&#123;user&#125;/.config/libvirt</span><br><span class="line">$ echo uri_default = <span class="string">"qemu:///system"</span> <span class="meta">&gt;&gt; </span>libvirt.conf</span><br></pre></td></tr></table></figure></p><h2 id="使用virsh-install创建虚拟机"><a href="#使用virsh-install创建虚拟机" class="headerlink" title="使用virsh-install创建虚拟机"></a>使用virsh-install创建虚拟机</h2><p>使用virsh-install命令可以在命令行下配置虚拟机：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ virt-install \</span><br><span class="line">  --virt-type=kvm \</span><br><span class="line">  --name=ubuntuserver1604 \</span><br><span class="line">  --ram=2048 \</span><br><span class="line">  --vcpus=2 \</span><br><span class="line">  --os-variant=ubuntu16.04 \</span><br><span class="line">  --hvm \</span><br><span class="line">  --cdrom=/home/colin/vhost/iso/ubuntuServer1604.iso \</span><br><span class="line">  --network=default,model=virtio \</span><br><span class="line">  --graphics vnc,listen=0.0.0.0 \</span><br><span class="line">  --disk path=/home/colin/vhost/image/ubuntuserver1604-2g-original.qcow2,size=20,bus=virtio,format=qcow2</span><br></pre></td></tr></table></figure></p><p>各个参数解释：<br>下面是各参数的意义：</p><ul><li>–virt-type=kvm: 使用KVM作为虚拟机监视器</li><li>–name=ubuntuserver1604: 虚拟机实例的名字，每个虚拟机的名字都不能一样，不能有空格</li><li>–ram=2048: 指定虚拟机内存大小，单位是Mb</li><li>–vcpus=2: 为虚拟机指定分配的虚拟CPU核数</li><li>–os-variant=ubuntu16.04: 指定虚拟机系统所属系列以优化虚拟机参数，可以通过命令osinfo-query os 来显示所有支持的系统列表，osinfo-query在包libosinfo-bin中 sudo apt-get install libosinfo-bin</li><li>–hvm: 启用全虚拟化，KVM虚拟机支持全虚拟化，属于优化性参数</li><li>–cdrom=/home/vhost/iso/ubuntuServer1604.iso: 指定作为虚拟机光驱内容的设备或文件，可以是主机的CDROM或者iso文件。</li><li>–network network=default,model=virtio: 将虚拟机连接到主机网络，此处连接到一个名为defalut的虚拟网络（即让虚拟机使用NAT模式上网），网卡模式设置为virtio。如果使用桥接模式，则只需要改参数为–network=bridge=br0,model=virtio即可。</li><li>–graphics vnc: 设置虚拟机的console并将其输出到VNC，这样就可以通过VNC来连接虚拟机了。同时可以指定vnc的端口和监听范围以及密码: –vncport=5910 –vnclisten=0.0.0.0。默认情况下端口为从5900开始的第一个空闲端口，监听范围为本机127.0.0.1，修改为0.0.0.0以使外网主机可以连接。后面会讲对于只支持SSH协议的情况下，如何通过SSH隧道连接，所以是否设置为0.0.0.0没有影响，但能设置为0.0.0.0的话，还是设置为0.0.0.0，毕竟直接通过VNC连接更加方便。这些参数也可以在/etc/libvirt/qemu.conf中修改，以使其对所有虚拟机生效，VNC默认连接没有密码。VNC可以理解为linux下的远程桌面</li><li>–disk path=/home/vhost/image/ubuntuserver1604-2g-original.qcow2,size=20,bus=virtio,format=qcow2: 指定虚拟机所使用的存储路径，大小为20G，disk bus类型为virtio，磁盘格式为raw，如果不指定fortmat，则默认格式即为raw。</li></ul><p>网络和磁盘建议都设置为virtio，virtio即启动优化的虚拟机专用IO驱动，性能更好。<br>磁盘格式使用qcow2更好，因为qcow2格式即QEMU支持的QEMU Copy On Write磁盘格式，是优化后的磁盘格式，支持快照，并且是使用多少占用多少空间。例如你分配了20G大小，如果是raw格式，则立即占用20G，而qcow2则是从很小开始，用多少，占用多少。之前有些人说qcow2性能不如raw，这两种格式可以使用qemu-img进行转换，qemu-img在包qemu-utils中。</p><h2 id="KVM管理常用命令"><a href="#KVM管理常用命令" class="headerlink" title="KVM管理常用命令"></a>KVM管理常用命令</h2><p>KVM虚拟机默认配置文件位置: /etc/libvirt/qemu/，该目录下存放了所有创建过的虚拟机配置文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ virsh list <span class="comment"># 查看正在运行的虚拟主机列表</span></span><br><span class="line">$ osinfo-query os <span class="comment"># 查看virt-install所支持的OS参数列表</span></span><br><span class="line">$ virsh list --all <span class="comment"># 查看所有的虚拟机列表</span></span><br><span class="line">$ virsh dominfo ubuntuserver1604 <span class="comment"># 查看虚拟机信息</span></span><br><span class="line">$ virsh start ubuntuserver1604 <span class="comment"># 启动虚拟机</span></span><br><span class="line">$ virsh shutdown ubuntuserver1604 <span class="comment"># 关闭虚拟机</span></span><br><span class="line">$ virsh <span class="built_in">suspend</span> ubuntuserver1604 <span class="comment"># 挂起虚拟机</span></span><br><span class="line">$ virsh reboot ubuntuserver1604 <span class="comment">#</span></span><br><span class="line">软重启（安全重启，相当于在虚拟机内部点击重启选项）虚拟机</span><br><span class="line">$ virsh reset ubuntuserver1604 <span class="comment"># 硬重启虚拟机（不安全，有可能数据丢失，相当于强制按主机上的重启按钮）</span></span><br><span class="line">$ virsh autostart ubuntuserver1604 <span class="comment"># 设置虚拟机随着宿主主机开机自动启动(开机自动启动的虚拟机配置文件会自动在目录/etc/libvirt/qemu/autostart/目录下生成)</span></span><br><span class="line">$ virsh autostart --<span class="built_in">disable</span> ubuntuserver1604 <span class="comment"># 取消开机自启动</span></span><br><span class="line">$ virsh destroy ubuntuserver1604 <span class="comment"># 强制关闭虚拟机电源</span></span><br><span class="line">$ virsh edit ubuntuserver1604 <span class="comment"># 编辑虚拟机配置文件</span></span><br><span class="line">$ virsh uri <span class="comment"># 查看当前主机上hypervisor的链接路径</span></span><br><span class="line">$ virsh undefine ubuntuserver1604 <span class="comment"># 移除虚拟机定义，即从虚拟机列表中移除虚拟机 该命令只是删除/etc/libvirt/qemu/目录下名为ubuntuserver1604.xml的配置文件，并不会删除虚拟机磁盘文件</span></span><br><span class="line">$ virsh define ubuntuserver1604.xml <span class="comment">#通过虚拟机配置文件重新定义虚拟机</span></span><br></pre></td></tr></table></figure></p><blockquote><p>注意，使用<code>virsh shutdown ubuntuserver1604</code>命令时，由于virsh实际上不能对虚拟机进行关机，只有虚拟机配置了acpid服务之后才能通过virsh进行关机，配置命令为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chkconfig acpid on</span><br><span class="line">$ sudo service acpid restart <span class="comment"># 注意这是指在虚拟机中配置该服务</span></span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="虚拟化" scheme="https://www.colins110.cn/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="KVM" scheme="https://www.colins110.cn/tags/KVM/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu安装nodejs</title>
    <link href="https://www.colins110.cn/2018/04/07/ubuntu%E5%AE%89%E8%A3%85nodejs/"/>
    <id>https://www.colins110.cn/2018/04/07/ubuntu安装nodejs/</id>
    <published>2018-04-07T15:01:04.000Z</published>
    <updated>2019-01-02T10:29:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>​ 通过ubuntu包管理器安装nodejs，需要引入第三方库。nodejs官方提供了添加脚本。在<a href="https://deb.nodesource.com/" target="_blank" rel="noopener">deb.nodesource.com</a> 中可以看到。<br>在终端中运行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure></p><p>就可以安装最新的nodejs 8.x版本了。其他版本可在<a href="https://deb.nodesource.com/" target="_blank" rel="noopener">deb.nodesource.com</a>上查找。<br><img src="/2018/04/07/ubuntu安装nodejs/nodejs_installer.png" alt="nodejs_installer.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="ubuntu" scheme="https://www.colins110.cn/categories/ubuntu/"/>
    
    
      <category term="ubuntu" scheme="https://www.colins110.cn/tags/ubuntu/"/>
    
      <category term="nodejs" scheme="https://www.colins110.cn/tags/nodejs/"/>
    
  </entry>
  
</feed>
