<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ubuntu16.04配置tpcc-mysql]]></title>
    <url>%2F2019%2F04%2F08%2Fubuntu16-04%E9%85%8D%E7%BD%AEtpcc-mysql%2F</url>
    <content type="text"><![CDATA[项目地址\ 安装mysql 12$ sudo apt install mysql-server$ sudo apt install libmysqlclient-dev #解决mysql_config缺失问题 编译 12$ cd src$ make 配置tpcc-mysql 创建数据库tpcctest 1$ sudo mysqladmin create tpcctest -p 创建表 1$ mysql tpcctest &lt; create_table.sql -u root -p 创建indexes和FK 1$ mysql tpcctest &lt; add_fkey_idx.sql -u root -p 填充数据 1$ ./tpcc_load -h 127.0.0.1 -d tpcctest -u root -p "123" -w 100 运行 1$ ./tpcc_start -h 127.0.0.1 -p 3306 -d tpcctest -u root -p "123" -c 32 -r 10 -l 10800 参考： 项目主页 TPCC-Mysql 测试]]></content>
      <categories>
        <category>benchmark</category>
      </categories>
      <tags>
        <tag>tpcc-mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu16.04配置SPARK-bench]]></title>
    <url>%2F2019%2F04%2F07%2Fubuntu16-04%E9%85%8D%E7%BD%AESPARK-bench%2F</url>
    <content type="text"><![CDATA[先看官网:直达链接运行SPARK-bench需要配置java环境和spark环境。具体可以google。这里简单介绍一下。 java环境配置 下载jdk包：jdk8 解压文件123$ tar -xvf jdk-8u201-linux-x64.tar.gz$ sudo mkdir /usr/lib/jdk$ mv jdk1.8.0_201 /usr/lib/jdk/ 配置环境变量在/etc/profile添加以下内容 12345#set java environmentexport JAVA_HOME=/usr/lib/jdk/jdk1.8.0_201export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 如果只是对当前用户更改环境变量，可以在~/.bashrc中修改。 spark环境配置 下载spark：spark 解压文件123$ tar -xvf spark-2.4.1-bin-hadoop2.7.tgz$ sudo mkdir /usr/lib/spark$ sudo mv spark-2.4.1-bin-hadoop2.7 /usr/lib/spark/ 配置环境变量在/etc/profile添加以下内容 123#set spark environmentexport SPARK_HOME=/usr/lib/spark/spark-2.4.1-bin-hadoop2.7export PATH=$&#123;SPARK_HOME&#125;/bin:$PATH 如果只是对当前用户更改环境变量，可以在~/.bashrc中修改。 配置Spark-Bench 下载spark-bench：releases page on Github 解压1$ tar -xvf spark-bench_2.3.0_0.4.0-RELEASE_99.tgz 配置环境变量： 第一种方式：设置bash环境变量 修改bin/spark-bench-env.sh文件中的SPARK_HOME 和 SPARK_MASTER_HOST变量。 第二种方式：修改配置文件(推荐)参考官方文档 运行]]></content>
      <categories>
        <category>benchmark</category>
      </categories>
      <tags>
        <tag>SPARK-bench</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[office2016零售版转VOL版]]></title>
    <url>%2F2019%2F03%2F27%2Foffice2016%E9%9B%B6%E5%94%AE%E7%89%88%E8%BD%ACVOL%E7%89%88%2F</url>
    <content type="text"><![CDATA[下载脚本管理员下运行脚本，选择要转换的选项，填入秘钥：XQNVK-8JYDB-WJ9W3-YJ8YR-WFG99 各版本vol秘钥]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>office</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu18.04配置PARSEC benchmark]]></title>
    <url>%2F2019%2F03%2F21%2Fubuntu18-04%E9%85%8D%E7%BD%AEPARSEC-benchmark%2F</url>
    <content type="text"><![CDATA[官方文档 安装必要环境 1sudo apt install make gcc g++ 下载PARSEC 3.0 1wget http://parsec.cs.princeton.edu/download/3.0/parsec-3.0.tar.gz 解压文件 12tar -xzf parsec-3.0.tar.gzcd parsec-3.0 运行脚本配置环境变量 1source env.sh 编译/运行/卸载 benchmarks 12345678910parsecmgmt -a build -p streamcluster #编译streamclusterparsecmgmt -a run -p streamcluster #运行streamcluster，默认使用test数据集parsecmgmt -a fulluninstall -p streamcluster #卸载streamcluster#Note that it may take several hours depending on your machineparsecmgmt -a build -p all #编译所有的benchparsecmgmt -a run -p all #运行所有的benchparsecmgmt -a fulluninstall -p streamcluster #卸载所有的benchparsecmgmt -a info -p streamcluster #查看streamcluster的信息，包括各种input数据集parsecmgmt -a run -p streamcluster -i native #使用native数据集测试 数据集可以参考官方介绍:注意，有的bench可能不止上述的输入，具体使用info选项查看。 环境配置：first，建议只装自己需要的且一个一个benchmark 装，除非很有耐心。1.blackscholes : 首先安装sudo apt-get install m42.dedup : encoder.c 增加 #include &lt;sys/stat.h&gt; 注：我在测试得时候发现 这个方法失效，暂时没有编译出来3.vips：缺少zlib sudo apt-get install zlib1g-dev 然后gettext 错误 sudo apt-get install libgtk2.0-dev http://www.cnblogs.com/soli/archive/2008/01/14/1039010.html4.raytrace:mesa 安装xorg-dev5.facesim:3.0中缺少input，可在有用网址2中找到 第一遍装的时候感觉很费劲，这次好多了，但也没有发现多少缺少的。只装了blackscholes，bodytrace，canneal，dedup，facesim，raytrace，streamcluster，swaptions，vips,x264.有用的网址：http://parsec.cs.princeton.edu/parsec3-doc.htmhttp://www.multi2sim.org/svn/m2s-bench-parsec-2.1/facesim/data-small/Face_Data/Eftychis_840k/ 参考：ubuntu 12.04 编译 parsec3.0 parsec-tutorial]]></content>
      <categories>
        <category>benchmark</category>
      </categories>
      <tags>
        <tag>PARSEC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DaCapo benchmark环境搭建]]></title>
    <url>%2F2019%2F03%2F19%2FDaCapo-benchmark%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[虚拟化性能测试需要使用benchmark测试，这里使用了DaCapo来实现。DaCapo基于java编写，需要java运行时环境，所以需要配置java环境。项目主页 在配置环境之前需要将host的hugepage关闭，运行一下命令关闭： 1sudo bash -c "echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled" 在guest中配置java 123sudo add-apt-repository ppa:webupd8team/javasudo apt updatesudo apt install oracle-java8-installer 使用java --version测试是否安装成功 下载DaCapo包下载地址：dacapo-9.12-MR1-bach.jar 常用命令 12345678java -jar dacapo-9.12-MR1-bach.jar #获取指令使用信息java -jar dacapo-9.12-MR1-bach.jar -l #列出所有benchmarkjava -jar dacapo-9.12-MR1-bach.jar avrora（benchmark名) #运行相应benchmark#dacapo对每一个benchmark提供了三种不同大小的负载java -jar dacapo-9.12-MR1-bach.jar -s small avrora #以小负载运行benchmarkjava -jar dacapo-9.12-MR1-bach.jar -s default avrora #以默认负载运行benchmarkjava -jar dacapo-9.12-MR1-bach.jar -s large avrora #以大负载运行benchmark 在不同负载下，同一个benchmark运行时间不同。benchmark相关的配置文件在文件夹dacapo-9.12-MR1-bach.jar/cnf中。附件：《The DaCapo Benchmarks: Java Benchmarking Development and Analysis》]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]Linux内核高端内存]]></title>
    <url>%2F2019%2F03%2F18%2F%E8%BD%AC-Linux%E5%86%85%E6%A0%B8%E9%AB%98%E7%AB%AF%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[原文地址 Linux内核地址映射模型x86 CPU采用了段页式地址映射模型。进程代码中的地址为逻辑地址，经过段页式地址映射后，才真正访问物理内存。段页式机制如下图。 Linux内核地址空间划分通常32位Linux内核地址空间划分0~3G为用户空间，3~4G为内核空间。注意这里是32位内核地址空间划分，64位内核地址空间划分是不同的。 Linux内核高端内存的由来当内核模块代码或线程访问内存时，代码中的内存地址都为逻辑地址，而对应到真正的物理内存地址，需要地址一对一的映射，如逻辑地址0xc0000003对应的物理地址为0x3，0xc0000004对应的物理地址为0x4，… …，逻辑地址与物理地址对应的关系为 物理地址 = 逻辑地址 – 0xC0000000 假设按照上述简单的地址映射关系，那么内核逻辑地址空间访问为0xc0000000 ~ 0xffffffff，那么对应的物理内存范围就为0x0 ~ 0x40000000，即只能访问1G物理内存。若机器中安装8G物理内存，那么内核就只能访问前1G物理内存，后面7G物理内存将会无法访问，因为内核的地址空间已经全部映射到物理内存地址范围0x0 ~ 0x40000000。即使安装了8G物理内存，那么物理地址为0x40000001的内存，内核该怎么去访问呢？代码中必须要有内存逻辑地址的，0xc0000000 ~ 0xffffffff的地址空间已经被用完了，所以无法访问物理地址0x40000000以后的内存。 显然不能将内核地址空间0xc0000000 ~ 0xfffffff全部用来简单的地址映射。因此x86架构中将物理地址划分三部分：ZONE_DMA、ZONE_NORMAL和ZONE_HIGHMEM。ZONE_HIGHMEM即为高端内存，这就是内存高端内存概念的由来。 在x86结构中，三种类型的区域如下： ZONE_DMA 内存开始的16MBZONE_NORMAL 16MB~896MBZONE_HIGHMEM 896MB ~ 结束 Linux内核高端内存的理解前面我们解释了高端内存的由来。 Linux将内核地址空间划分为三部分ZONE_DMA、ZONE_NORMAL和ZONE_HIGHMEM，高端内存HIGH_MEM地址空间范围为0xF8000000 ~ 0xFFFFFFFF（896MB～1024MB）。那么如内核是如何借助128MB高端内存地址空间是如何实现访问可以所有物理内存？ 当内核想访问高于896MB物理地址内存时，从0xF8000000 ~ 0xFFFFFFFF地址空间范围内找一段相应大小空闲的逻辑地址空间，借用一会。借用这段逻辑地址空间，建立映射到想访问的那段物理内存（即填充内核PTE页面表），临时用一会，用完后归还。这样别人也可以借用这段地址空间访问其他物理内存，实现了使用有限的地址空间，访问所有所有物理内存。如下图。例如内核想访问2G开始的一段大小为1MB的物理内存，即物理地址范围为0x80000000 ~ 0x800FFFFF。访问之前先找到一段1MB大小的空闲地址空间，假设找到的空闲地址空间为0xF8700000 ~ 0xF87FFFFF，用这1MB的逻辑地址空间映射到物理地址空间0x80000000 ~ 0x800FFFFF的内存。映射关系如下：当内核访问完0x80000000 ~ 0x800FFFFF物理内存后，就将0xF8700000 ~ 0xF87FFFFF内核线性空间释放。这样其他进程或代码也可以使用0xF8700000 ~ 0xF87FFFFF这段地址访问其他物理内存。从上面的描述，我们可以知道高端内存的最基本思想：借一段地址空间，建立临时地址映射，用完后释放，达到这段地址空间可以循环使用，访问所有物理内存。看到这里，不禁有人会问：万一有内核进程或模块一直占用某段逻辑地址空间不释放，怎么办？若真的出现的这种情况，则内核的高端内存地址空间越来越紧张，若都被占用不释放，则没有建立映射到物理内存都无法访问了。在香港尖沙咀有些写字楼，洗手间很少且有门锁的。客户要去洗手间的话，可以向前台拿钥匙，方便完后，把钥匙归还到前台。这样虽然只有一个洗手间，但可以满足所有客户去洗手间的需求。要是某个客户一直占用洗手间、钥匙不归还，那么其他客户都无法上洗手间了。Linux内核高端内存管理的思想类似。 Linux内核高端内存的划分内核将高端内存划分为3部分：VMALLOC_START~VMALLOC_END、KMAP_BASE~FIXADDR_START和FIXADDR_START~4G。对于高端内存，可以通过 alloc_page() 或者其它函数获得对应的 page，但是要想访问实际物理内存，还得把 page 转为线性地址才行（为什么？想想 MMU 是如何访问物理内存的），也就是说，我们需要为高端内存对应的 page 找一个线性空间，这个过程称为高端内存映射。对应高端内存的3部分，高端内存映射有三种方式： 映射到”内核动态映射空间”（noncontiguous memory allocation）这种方式很简单，因为通过 vmalloc() ，在”内核动态映射空间”申请内存的时候，就可能从高端内存获得页面（参看 vmalloc 的实现），因此说高端内存有可能映射到”内核动态映射空间”中。 持久内核映射（permanent kernel mapping）如果是通过 alloc_page() 获得了高端内存对应的 page，如何给它找个线性空间？内核专门为此留出一块线性空间，从 PKMAP_BASE 到 FIXADDR_START ，用于映射高端内存。在 2.6内核上，这个地址范围是 4G-8M 到 4G-4M 之间。这个空间起叫”内核永久映射空间”或者”永久内核映射空间”。这个空间和其它空间使用同样的页目录表，对于内核来说，就是 swapper_pg_dir，对普通进程来说，通过 CR3 寄存器指向。通常情况下，这个空间是 4M 大小，因此仅仅需要一个页表即可，内核通过来 pkmap_page_table 寻找这个页表。通过 kmap()，可以把一个 page 映射到这个空间来。由于这个空间是 4M 大小，最多能同时映射 1024 个 page。因此，对于不使用的的 page，及应该时从这个空间释放掉（也就是解除映射关系），通过 kunmap() ，可以把一个 page 对应的线性地址从这个空间释放出来。 临时映射（temporary kernel mapping）内核在 FIXADDR_START 到 FIXADDR_TOP 之间保留了一些线性空间用于特殊需求。这个空间称为”固定映射空间”在这个空间中，有一部分用于高端内存的临时映射。 这块空间具有如下特点：（1）每个 CPU 占用一块空间（2）在每个 CPU 占用的那块空间中，又分为多个小空间，每个小空间大小是 1 个page，每个小空间用于一个目的，这些目的定义在 kmap_types.h 中的 km_type 中。 当要进行一次临时映射的时候，需要指定映射的目的，根据映射目的，可以找到对应的小空间，然后把这个空间的地址作为映射地址。这意味着一次临时映射会导致以前的映射被覆盖。通过 kmap_atomic() 可实现临时映射。 常见问题： 用户空间（进程）是否有高端内存概念？用户进程没有高端内存概念。只有在内核空间才存在高端内存。用户进程最多只可以访问3G物理内存，而内核进程可以访问所有物理内存。 64位内核中有高端内存吗？目前现实中，64位Linux内核不存在高端内存，因为64位内核可以支持超过512GB内存。若机器安装的物理内存超过内核地址空间范围，就会存在高端内存。 用户进程能访问多少物理内存？内核代码能访问多少物理内存？32位系统用户进程最大可以访问3GB，内核代码可以访问所有物理内存。64位系统用户进程最大可以访问超过512GB，内核代码可以访问所有物理内存。 高端内存和物理地址、逻辑地址、线性地址的关系？高端内存只和物理地址有关系，和线性地址、逻辑地址没有直接关系。 为什么不把所有的地址空间都分配给内核？若把所有地址空间都给内存，那么用户进程怎么使用内存？怎么保证内核使用内存和用户进程不起冲突？]]></content>
      <categories>
        <category>linux内核</category>
      </categories>
      <tags>
        <tag>linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git设置和取消代理]]></title>
    <url>%2F2019%2F03%2F08%2Fgit%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%8F%96%E6%B6%88%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[查看当前代理设置：12git config --global http.proxygit config --global https.proxy 设置代理：1234git config --global http.proxy 'http://127.0.0.1:1080'git config --global https.proxy 'https://127.0.0.1:1080'git config --global http.proxy 'socks5://127.0.0.1:1080' git config --global https.proxy 'socks5://127.0.0.1:1080' 取消设置：12git config --global --unset http.proxygit config --global --unset https.proxy]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[台湾清华彭明辉教授的研究生手册(学习方法论)]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%8F%B0%E6%B9%BE%E6%B8%85%E5%8D%8E%E5%BD%AD%E6%98%8E%E8%BE%89%E6%95%99%E6%8E%88%E7%9A%84%E7%A0%94%E7%A9%B6%E7%94%9F%E6%89%8B%E5%86%8C-%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[原文地址]]></content>
      <categories>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>方法论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下KVM虚拟机创建]]></title>
    <url>%2F2019%2F02%2F28%2Fubuntu%E4%B8%8BKVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[网上关于KVM虚拟机创建的文章有很多，但是都是只提供命令，没有解释。对于初学者很不友好，这里记录下我自己的实践。因为我的服务器使用的是ubuntu16.04，所以以下操作都是基于此系统。我是在windows下使用MobaXterm来连接我自己的服务器的，这里强力推荐这款软件，非常方便。 以下代码’#’后的内容为注释‘$’后为执行命令 验证主机是否支持硬件虚拟化12cat /proc/cpuinfo | grep svm # AMD硬件cat /proc/cpuinfo | grep vmx # Intel硬件 svm是ADM的ADM-V虚拟化技术标识，全称secure virtual machine，vmx是Intel的硬件虚拟化技术VT-x，标识是vmx，全称为virtual machine extension。通过查询cpuinfo文件，可以知道硬件是否支持虚拟化。若返回结果中有svm或者vmx则说明硬件支持虚拟化。 安装必要依赖1$ sudo apt install qemu-kvm libvirt-bin virtinst bridge-utils virt-viewer virt-manager kvm:linux系统自带，已经编译进linux内核 qemu-kvm：KVM的设备模拟器，因为KVM只负责CPU和内存的虚拟化，独立无法完成整个系统的虚拟化，所以KVM开发者使用成熟的qemu来完成其他部件的虚拟化，qemu负责虚拟机的管理，kvm负责加速 libvirt：Libvirt是用于管理虚拟化平台的开源的API，后台程序和管理工具。它可以用于管理KVM、Xen、VMware ESX，QEMU和其他虚拟化技术 virtinst: 虚拟机创建（virt-install）和克隆工具（vrit-clone）等 birdge-utils: 用于桥接网卡的工具 virt-viewer：连接虚拟机屏幕的工具，需要桌面环境支持，使用mobaXterm可以远程使用x11图形界面，非常方便。 virt-manager：gui虚拟机管理工具，类似于windows上的vmware workstation KVM管理工具的一些注解及一些实用工具 libvirt：操作和管理KVM虚机的虚拟化API，使用C语言编写，可以由Python,Ruby, Perl, PHP, Java等语言调用。可以操作包括KVM，vmware，XEN，Hyper-v, LXC，virtualbox等 Hypervisor。 virsh：基于libvirt的命令行工具，后面需要大量使用 virt-v2v：虚机格式迁移工具，该工具与virt-sysprep都包含在包libguestfs-tools中，后面布署中会用到 virt-install：创建KVM虚机的命令行工具 virt-viewer：连接到虚拟机屏幕的工具，需要主机有桌面环境，该工具需要单独安装sudo apt-get install virt-viewer virt-clone：虚机克隆工具 virt-top：类似于linux系统下的top命令，可以显示所有虚拟机CPU、内存等使用情况，该工具需要单独安装sudo apt-get install virt-top 虚拟机创建默认情况下，在安装完上述环境后，会自动配置好一个默认的网络环境default,可以使用如下命令查看：1$ sudo virsh net-list --all 假如不小心通过brctl（用于管理桥接网络的工具）删除了default网络，可以通过重新加载预置的XML文件来恢复：123456$ sudo virsh net-define /usr/share/libvirt/networks/default.xml #重新定义网络Network default defined from /usr/share/libvirt/networks/default.xml$ sudo virsh net-autostart default #设置default开机自动启动Network default marked as autostarted$ sudo virsh net-start default #启动网络defaultNetwork default started 这里默认的配置是nat模式，即guestOS可以通过host上网，而在外部看不到guest。 为了让非root用户可以直接使用virsh命令管理虚拟机，需要将普通用户加入到kvm和libvirt用户组中：12$ sudo adduser &lt;youruser&gt; kvm$ sudo adduser &lt;youruser&gt; libvirtd centos 使用：12$ sudo gpasswd -a &lt;youruser&gt; kvm$ sudo gpasswd -a &lt;youruser&gt; libvirt 这个时候重新登录就会使新的用户组成员生效了。 使用virt-manager创建虚拟机新手推荐使用图形化界面创建虚拟机。使用MobaXterm连接服务器时原生支持x11，所以直接在shell中运行virt-manager就可以了，配置同vmware类似，这里就不多介绍了注意:在centos 7 上使用virt-manager安装时，显示协议选择spice时，需要gtk支持：1$ sudo yum install gtk3 centos 7上安装的virsh的uri默认为qemu:///session,可以在用户目录下使用配置文件更改：12$ cd /home/&#123;user&#125;/.config/libvirt$ echo uri_default = "qemu:///system" &gt;&gt; libvirt.conf 使用virsh-install创建虚拟机使用virsh-install命令可以在命令行下配置虚拟机：1234567891011$ virt-install \ --virt-type=kvm \ --name=ubuntuserver1604 \ --ram=2048 \ --vcpus=2 \ --os-variant=ubuntu16.04 \ --hvm \ --cdrom=/home/colin/vhost/iso/ubuntuServer1604.iso \ --network=default,model=virtio \ --graphics vnc,listen=0.0.0.0 \ --disk path=/home/colin/vhost/image/ubuntuserver1604-2g-original.qcow2,size=20,bus=virtio,format=qcow2 各个参数解释：下面是各参数的意义： –virt-type=kvm: 使用KVM作为虚拟机监视器 –name=ubuntuserver1604: 虚拟机实例的名字，每个虚拟机的名字都不能一样，不能有空格 –ram=2048: 指定虚拟机内存大小，单位是Mb –vcpus=2: 为虚拟机指定分配的虚拟CPU核数 –os-variant=ubuntu16.04: 指定虚拟机系统所属系列以优化虚拟机参数，可以通过命令osinfo-query os 来显示所有支持的系统列表，osinfo-query在包libosinfo-bin中 sudo apt-get install libosinfo-bin –hvm: 启用全虚拟化，KVM虚拟机支持全虚拟化，属于优化性参数 –cdrom=/home/vhost/iso/ubuntuServer1604.iso: 指定作为虚拟机光驱内容的设备或文件，可以是主机的CDROM或者iso文件。 –network network=default,model=virtio: 将虚拟机连接到主机网络，此处连接到一个名为defalut的虚拟网络（即让虚拟机使用NAT模式上网），网卡模式设置为virtio。如果使用桥接模式，则只需要改参数为–network=bridge=br0,model=virtio即可。 –graphics vnc: 设置虚拟机的console并将其输出到VNC，这样就可以通过VNC来连接虚拟机了。同时可以指定vnc的端口和监听范围以及密码: –vncport=5910 –vnclisten=0.0.0.0。默认情况下端口为从5900开始的第一个空闲端口，监听范围为本机127.0.0.1，修改为0.0.0.0以使外网主机可以连接。后面会讲对于只支持SSH协议的情况下，如何通过SSH隧道连接，所以是否设置为0.0.0.0没有影响，但能设置为0.0.0.0的话，还是设置为0.0.0.0，毕竟直接通过VNC连接更加方便。这些参数也可以在/etc/libvirt/qemu.conf中修改，以使其对所有虚拟机生效，VNC默认连接没有密码。VNC可以理解为linux下的远程桌面 –disk path=/home/vhost/image/ubuntuserver1604-2g-original.qcow2,size=20,bus=virtio,format=qcow2: 指定虚拟机所使用的存储路径，大小为20G，disk bus类型为virtio，磁盘格式为raw，如果不指定fortmat，则默认格式即为raw。 网络和磁盘建议都设置为virtio，virtio即启动优化的虚拟机专用IO驱动，性能更好。磁盘格式使用qcow2更好，因为qcow2格式即QEMU支持的QEMU Copy On Write磁盘格式，是优化后的磁盘格式，支持快照，并且是使用多少占用多少空间。例如你分配了20G大小，如果是raw格式，则立即占用20G，而qcow2则是从很小开始，用多少，占用多少。之前有些人说qcow2性能不如raw，这两种格式可以使用qemu-img进行转换，qemu-img在包qemu-utils中。 KVM管理常用命令KVM虚拟机默认配置文件位置: /etc/libvirt/qemu/，该目录下存放了所有创建过的虚拟机配置文件。1234567891011121314151617$ virsh list # 查看正在运行的虚拟主机列表$ osinfo-query os # 查看virt-install所支持的OS参数列表$ virsh list --all # 查看所有的虚拟机列表$ virsh dominfo ubuntuserver1604 # 查看虚拟机信息$ virsh start ubuntuserver1604 # 启动虚拟机$ virsh shutdown ubuntuserver1604 # 关闭虚拟机$ virsh suspend ubuntuserver1604 # 挂起虚拟机$ virsh reboot ubuntuserver1604 #软重启（安全重启，相当于在虚拟机内部点击重启选项）虚拟机$ virsh reset ubuntuserver1604 # 硬重启虚拟机（不安全，有可能数据丢失，相当于强制按主机上的重启按钮）$ virsh autostart ubuntuserver1604 # 设置虚拟机随着宿主主机开机自动启动(开机自动启动的虚拟机配置文件会自动在目录/etc/libvirt/qemu/autostart/目录下生成)$ virsh autostart --disable ubuntuserver1604 # 取消开机自启动$ virsh destroy ubuntuserver1604 # 强制关闭虚拟机电源$ virsh edit ubuntuserver1604 # 编辑虚拟机配置文件$ virsh uri # 查看当前主机上hypervisor的链接路径$ virsh undefine ubuntuserver1604 # 移除虚拟机定义，即从虚拟机列表中移除虚拟机 该命令只是删除/etc/libvirt/qemu/目录下名为ubuntuserver1604.xml的配置文件，并不会删除虚拟机磁盘文件$ virsh define ubuntuserver1604.xml #通过虚拟机配置文件重新定义虚拟机 注意，使用virsh shutdown ubuntuserver1604命令时，由于virsh实际上不能对虚拟机进行关机，只有虚拟机配置了acpid服务之后才能通过virsh进行关机，配置命令为：12$ sudo chkconfig acpid on$ sudo service acpid restart # 注意这是指在虚拟机中配置该服务]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu安装nodejs]]></title>
    <url>%2F2018%2F04%2F07%2Fubuntu%E5%AE%89%E8%A3%85nodejs%2F</url>
    <content type="text"><![CDATA[​ 通过ubuntu包管理器安装nodejs，需要引入第三方库。nodejs官方提供了添加脚本。在deb.nodesource.com 中可以看到。在终端中运行:12curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -sudo apt-get install -y nodejs 就可以安装最新的nodejs 8.x版本了。其他版本可在deb.nodesource.com上查找。]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用IntelliJ IDEA创建Hibernate项目]]></title>
    <url>%2F2017%2F07%2F09%2F%E4%BD%BF%E7%94%A8IntelliJ-IDEA%E5%88%9B%E5%BB%BAHibernate%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[最近正在学习web开发的三大框架即SSH ，目前正在学习Hibernate 操作数据库，由于其版本的更新，其中需要注意到的一些小问题。 下面是在IntelliJ IDEA下创建一个Hibernate项目的过程。目前来说，IntelliJ IDEA作为一款优秀的IDE开发工具，其工具集成度很高。所以我们可以直接建立一个Hibernate项目：勾选Hibernate框架，这里我们看到Hibernate的最新版是5.2.10，勾选Create default hibernate configuratuion and main class ，让IDE为我们自动生成Hibernate的配置文（Hibernate.cfg.xml)， 等待IDE为我们下载好所需的jar包，完成项目的创建。 接下来我们创建一个包，包名为com.colins110.test，看到我们的Hibernate 配置文件已经自动创建了，我们要对配置文件进行一些修改：这里我使用的是mysql，需要导入mysql的驱动包，这里我是用的是mysql-connector-java-5.1.42，在mysql官网可以获取。配置如下: 连接url：jdbc:mysql:///hibernate?useUnicode=true&amp;characterEncoding=UTF-8 我的数据库名为hibernate ，?后表明使用unicode字符集，在xml文件中&amp;需要写成&amp;amp;。 数据库驱动：com.mysql.jdbc.Driver这里使用的是上面导入的驱动包 用户名：默认为root 密码：我的密码为空 使用方言：mysql方言有多种，这里选择org.hibernate.dialect.MySQL5Dialect新版方言 show_sql属性：在命令行显示生成的sql语句format_sql属性：格式化输出sql语句 hbm2ddl属性：设置为create，每次重新创建表 这样我们的Hibernate环境就配置好了 接下来需要配置一个实体类，用来表示数据库中的一个表，每个实体类对象则表示表中的一条记录，这样的话，我们在编程的时候只需要面向对象编程，而不需要写SQL语句了。 在这里我建立了一个Students类，这是一个典型的java Bean12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.colins110.test;import java.util.Date;/** * Created by colin on 2017/7/9 0009. *///学生类public class Students &#123; private int sid; private String sname; private String gender; private Date birthday; private String address; public Students() &#123;&#125; public Students(int sid, String sname, String gender, Date birthday, String address) &#123; this.sid = sid; this.sname = sname; this.gender = gender; this.birthday = birthday; this.address = address; &#125; public int getSid() &#123; return sid; &#125; public void setSid(int sid) &#123; this.sid = sid; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "Students&#123;" + "sid=" + sid + ", sname='" + sname + '\'' + ", gender='" + gender + '\'' + ", birthday=" + birthday + ", address='" + address + '\'' + '&#125;'; &#125;&#125; 现在需要建立一个对应的配置文件，指明java Bean和数据库中表的映射关系，这里是Students.hbm.xml。12345678910111213141516171819202122232425&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.colins110.test.Students" table="Students"&gt; &lt;id name="sid" type="int"&gt; &lt;column name="id" /&gt; &lt;generator class="assigned"/&gt; &lt;/id&gt; &lt;property name="sname" type="java.lang.String"&gt; &lt;column name="name" /&gt; &lt;/property&gt; &lt;property name="gender" type="java.lang.String"&gt; &lt;column name="sex" /&gt; &lt;/property&gt; &lt;property name="birthday" type="java.util.Date"&gt; &lt;column name="birthday" /&gt; &lt;/property&gt; &lt;property name="address" type="java.lang.String"&gt; &lt;column name="address"/&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 下载需要将Students.hbm.xml映射文件配置到配置文件中：下面使用Juint4对hibernate进行测试 编写测试代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.colins110.test;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.boot.registry.StandardServiceRegistryBuilder;import org.hibernate.cfg.Configuration;import org.hibernate.service.ServiceRegistry;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.util.Date;import static org.junit.Assert.*;/** * Created by colin on 2017/7/9 0009. */public class StudentsTest &#123; private Configuration config; private SessionFactory sf; private Session session; private Transaction transaction; @Before public void setUp() throws Exception &#123; config=new Configuration().configure(); ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(config.getProperties()).configure().build(); sf=config.buildSessionFactory(serviceRegistry); session=sf.openSession(); transaction=session.beginTransaction(); &#125; @After public void tearDown() throws Exception &#123; transaction.commit(); session.close(); sf.close(); &#125; @Test public void test() &#123; Students user=new Students(120,"董健","男",new Date(),"四川"); session.save(user); &#125;&#125; 注意： 在5.x版的Hibernate中，需要使用ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(config.getProperties()).configure().build();来注册服务在4.x中使用ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(config.getProperties()).buildServiceRegistry();来注册服务]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>IntelliJ IDEA</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用win10创意者更新自带工具MBR2GPT完成系统盘的MBR到GPT的无损转换]]></title>
    <url>%2F2017%2F06%2F11%2F%E4%BD%BF%E7%94%A8win10%E5%88%9B%E6%84%8F%E8%80%85%E6%9B%B4%E6%96%B0%E8%87%AA%E5%B8%A6%E5%B7%A5%E5%85%B7MBR2GPT%E5%AE%8C%E6%88%90%E7%B3%BB%E7%BB%9F%E7%9B%98%E7%9A%84MBR%E5%88%B0GPT%E7%9A%84%E6%97%A0%E6%8D%9F%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[之前如果需要将MBR格式的硬盘转换为GPT硬盘，要么选择格盘重装系统，这样数据会丢失。如果需要数据无损转换的话，手工转换比较复杂，或者可以使用第三方的分区工具完成。这里我们介绍微软官方提供的无损转换工具MBR2GPT，工具已经内置到win10创意者更新里了，这里我们可以在命令行里直接调用！ 这是官方参考文档: 点此阅读 注意事项 在转换过程中会创建UEFI系统分区，这会占用一个MBR主分区，而因为MBR磁盘最多只能有四个主分区，所以待转换的MBR磁盘不能超过四个主分区； BitLocker加密磁盘需要先解除BitLocker加密之后才能使用MBR2GPT进行转换； 即使当前安装的Win10 1703之前的早期Win10版本（1607，1511，1507），依然能够使用MBR2GPT进行转换，只不过需要使用Win10 1703系统盘启动进入WinRE环境，才能运行MBR2GPT工具。 这是我们演示将本机的系统盘转换为GPT文件格式步骤一:启动进入WinRE环境，如果不懂如何进入，请点击阅读 进入后选择命令提示符 步骤二使用命令disk查看里的磁盘序号。 步骤三启动MBR2GPT程序，带上参数/validate和/disk:1，用于指定对1号磁盘（系统盘）进行检查，如果提示successfully说明可以进行转换。1mbr2gpt /validate /disk:1 开始转换完成后类似如下提示:1234567891011121314151617MBR2GPT will now attempt to convert disk 0.If conversion is successful the disk can only be booted in GPT mode.These changes cannot be undone!MBR2GPT: Attempting to convert disk 0MBR2GPT: Retrieving layout of diskMBR2GPT: Validating layout, disk sector size is: 512 bytesMBR2GPT: Trying to shrink the system partitionMBR2GPT: Trying to shrink the OS partitionMBR2GPT: Creating the EFI system partitionMBR2GPT: Installing the new boot filesMBR2GPT: Performing the layout conversionMBR2GPT: Migrating default boot entryMBR2GPT: Adding recovery boot entryMBR2GPT: Fixing drive letter mappingMBR2GPT: Conversion completed successfullyMBR2GPT: Before the new system can boot properly you need to switch the firmware to boot to UEFI mode! 最后记得将主板上的启动模式改为UEFI mode!更多细节参见官方手册]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>分区无损转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2017%2F06%2F06%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这是我的第一篇文章首先，回忆一下Markdown语法 标题 标题可以根据字体大小分为六级，分别用不同数量的#表示【效果】 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题【输入】123456#这是一级标题##这是二级标题###这是三级标题####这是四级标题#####这是五级标题######这是六级标题 文本 【效果】粗体斜体粗体+斜体【输入】123**这是粗体***这是斜体****这是粗体+斜体*** 图片 【效果】【输入】1![我的博客主页](Markdown语法/我的主页.png) 列表 列表分为有序列表和无序列表无序列表可以通过在每行文本前输入*,+,-来实现【效果】 星号实现的列表 加号实现的列表 减号实现的列表 注意符号与文本之间要有一个空格 【输入】1234* 星号实现的列表+ 加号实现的列表- 减号实现的列表* 注意符号与文本之间要有一个空格 有序列表可以通过在每行文本前面输入数字+.+空格来实现【效果】 第一行 第二行 第三行 【输入】1231. 第一行2. 第二行3. 第三行 引用 【效果】 这是一段引用啦 【输入】1&gt;这是一段引用啦 行内代码块 行内代码块可用于关键字词，将其与普通文本文件分别开来，其用法是在文本内容外套上”`“，即反引号。 【效果】这是一段行内代码块【输入】1`这是一段行内代码块` 代码块 【效果】12345public class test&#123; public static void main()&#123; System.out.println("This is a test_class!"); &#125;&#125; 表格 【效果】|默认|居中|左对齐|右对齐||–|:-:|:-|-:||换行\n换行失败|我的Markdown|不支持|换行||支持斜体|粗体|斜体+粗体|||# 不支持标题|支持链接||支持行内代码块 | 【输入】12345|默认|居中|左对齐|右对齐||--|:-:|:-|-:||换行\n换行失败|我的Markdown|不支持|换行||*支持斜体*|**粗体**|***斜体+粗体***|||# 不支持标题|[支持链接](http://jianshu.com)|![支持图片](https://cdn.sspai.com/attachment/origin/2014/04/15/69488.png?imageMogr2/quality/90/thumbnail/100x)|`支持行内代码块` | 删除线 【效果】删除线【输入】1~~删除线~~ 分割线 分割线可使用*、-来实现。【效果】 【输入】12---***]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10进入恢复模式]]></title>
    <url>%2F2017%2F06%2F01%2FWin10%E8%BF%9B%E5%85%A5%E6%81%A2%E5%A4%8D%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[【科普】 什么是windows恢复模式windows恢复环境 (Windows Recovery Environment),，简称WinRE，是微软从Windows Vista开始引入的用于系统恢复和还原的一套环境。WinRE默认安装在系统分区前的隐藏分区中。 那么如何进入呢？ 方法一： Win10单系统开机时按F8键进入WinRE如果你的电脑是Windows10单系统的话，开机不停地按F8键即可进入WInRE。 方法二：通过设置进入WinRE1.打开电脑设置2.进入更新和安全，在恢复选项中点击高级启动立即重启 3.系统重启后进入恢复模式]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>恢复模式</tag>
      </tags>
  </entry>
</search>
